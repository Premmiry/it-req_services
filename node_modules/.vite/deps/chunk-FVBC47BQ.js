import {
  DATA_GRID_DEFAULT_SLOTS_COMPONENTS,
  DATA_GRID_PROPS_DEFAULT_VALUES,
  EMPTY_DETAIL_PANELS,
  GRID_CHECKBOX_SELECTION_FIELD,
  GRID_COLUMN_MENU_SLOTS,
  GRID_COLUMN_MENU_SLOT_PROPS,
  GRID_DEFAULT_LOCALE_TEXT,
  GRID_ROOT_GROUP_ID,
  GRID_STRING_COL_DEF,
  GridBaseColumnHeaders,
  GridColumnHeaderRow,
  GridContextProvider,
  GridFooterPlaceholder,
  GridGenericColumnMenu,
  GridHeader,
  GridMenu,
  GridPinnedColumnPosition,
  GridRoot,
  GridSignature,
  GridVirtualScroller,
  buildRootGroup,
  columnGroupsStateInitializer,
  columnMenuStateInitializer,
  columnResizeStateInitializer,
  columnsStateInitializer,
  computeSlots,
  createSelector,
  createSelectorMemoized,
  densityStateInitializer,
  dimensionsStateInitializer,
  editingStateInitializer,
  eslintUseValue,
  fastMemo,
  filterStateInitializer,
  focusStateInitializer,
  getDataGridUtilityClass,
  getGridFilter,
  getRowIdFromRowModel,
  getTreeNodeDescendants,
  getVisibleRows,
  gridClasses,
  gridColumnFieldsSelector,
  gridColumnLookupSelector,
  gridColumnPositionsSelector,
  gridColumnVisibilityModelSelector,
  gridColumnsTotalWidthSelector,
  gridDataRowIdsSelector,
  gridDimensionsSelector,
  gridEditRowsStateSelector,
  gridFilterModelSelector,
  gridFilterableColumnLookupSelector,
  gridFilteredDescendantCountLookupSelector,
  gridFocusColumnHeaderFilterSelector,
  gridHeaderFilteringEditFieldSelector,
  gridHeaderFilteringMenuSelector,
  gridPinnedColumnsSelector,
  gridPinnedRowsSelector,
  gridRenderContextSelector,
  gridRowMaximumTreeDepthSelector,
  gridRowTreeSelector,
  gridSortModelSelector,
  gridTabIndexColumnHeaderFilterSelector,
  gridVisibleColumnDefinitionsSelector,
  gridVisibleColumnFieldsSelector,
  gridVisiblePinnedColumnDefinitionsSelector,
  isDeepEqual,
  isEventTargetInPortal,
  isNavigationKey,
  isNumber,
  paginationStateInitializer,
  passFilterLogic,
  preferencePanelStateInitializer,
  propValidatorsDataGrid,
  rowSelectionStateInitializer,
  rowsMetaStateInitializer,
  rowsStateInitializer,
  shouldCellShowLeftBorder,
  shouldCellShowRightBorder,
  sortingStateInitializer,
  useFirstRender,
  useGridApiContext,
  useGridApiEventHandler,
  useGridApiMethod,
  useGridApiOptionHandler,
  useGridApiRef,
  useGridClipboard,
  useGridColumnGrouping,
  useGridColumnHeaders,
  useGridColumnMenu,
  useGridColumnResize,
  useGridColumnSpanning,
  useGridColumns,
  useGridCsvExport,
  useGridDensity,
  useGridDimensions,
  useGridEditing,
  useGridEvents,
  useGridFilter,
  useGridFocus,
  useGridInitialization,
  useGridInitializeState,
  useGridKeyboardNavigation,
  useGridLogger,
  useGridPagination,
  useGridParamsApi,
  useGridPreferencesPanel,
  useGridPrintExport,
  useGridPrivateApiContext,
  useGridRegisterPipeProcessor,
  useGridRegisterStrategyProcessor,
  useGridRootProps,
  useGridRowSelection,
  useGridRowSelectionPreProcessors,
  useGridRows,
  useGridRowsMeta,
  useGridRowsPreProcessors,
  useGridScroll,
  useGridSelector,
  useGridSorting,
  useGridStatePersistence,
  useGridVirtualization,
  useGridVisibleRows,
  useProps,
  useResizeObserver,
  validateProps,
  virtualizationStateInitializer
} from "./chunk-R4NMRHAP.js";
import {
  ListItemIcon_default,
  ListItemText_default,
  MenuItem_default,
  MenuList_default
} from "./chunk-R7BREFST.js";
import {
  Box_default
} from "./chunk-TTS3LHGG.js";
import {
  useTheme
} from "./chunk-SEAJWC4T.js";
import {
  styled_default as styled_default2
} from "./chunk-7MS3XS74.js";
import {
  init_utils as init_utils2
} from "./chunk-LH6WIWXB.js";
import {
  createSvgIcon
} from "./chunk-TLREMOBU.js";
import {
  HTMLElementType,
  init_useEventCallback,
  init_utils,
  ponyfillGlobal_default,
  refType_default,
  useEventCallback_default,
  useForkRef,
  useId
} from "./chunk-WRWSQIQX.js";
import {
  styled_default
} from "./chunk-ZHOTP5FO.js";
import {
  useThemeProps2 as useThemeProps
} from "./chunk-BQFGJCJQ.js";
import {
  capitalize,
  composeClasses
} from "./chunk-DOTEVOMS.js";
import {
  _objectWithoutPropertiesLoose,
  clsx_default,
  init_clsx,
  init_objectWithoutPropertiesLoose
} from "./chunk-CBHUOLM3.js";
import {
  _extends,
  init_extends,
  require_prop_types
} from "./chunk-WFASZELL.js";
import {
  require_jsx_runtime
} from "./chunk-ORQ5YSUV.js";
import {
  require_react
} from "./chunk-NDH4SAXN.js";
import {
  __toESM
} from "./chunk-WGAPYIUP.js";

// node_modules/@mui/x-license/encoding/md5.js
var k = [];
var i = 0;
for (; i < 64; ) {
  k[i] = 0 | Math.sin(++i % Math.PI) * 4294967296;
}
function md5(s) {
  const words = [];
  let b, c, d, j = unescape(encodeURI(s)) + "Â€", a = j.length;
  const h = [b = 1732584193, c = 4023233417, ~b, ~c];
  s = --a / 4 + 2 | 15;
  words[--s] = a * 8;
  for (; ~a; ) {
    words[a >> 2] |= j.charCodeAt(a) << 8 * a--;
  }
  for (i = j = 0; i < s; i += 16) {
    a = h;
    for (; j < 64; a = [d = a[3], b + ((d = a[0] + [b & c | ~b & d, d & b | ~d & c, b ^ c ^ d, c ^ (b | ~d)][a = j >> 4] + k[j] + ~~words[i | [j, 5 * j + 1, 3 * j + 5, 7 * j][a] & 15]) << (a = [7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21][4 * a + j++ % 4]) | d >>> -a), b, c]) {
      b = a[1] | 0;
      c = a[2];
    }
    for (j = 4; j; )
      h[--j] += a[j];
  }
  for (s = ""; j < 32; ) {
    s += (h[j >> 3] >> (1 ^ j++) * 4 & 15).toString(16);
  }
  return s;
}

// node_modules/@mui/x-license/encoding/base64.js
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var base64Decode = (input) => {
  let output = "";
  let chr1, chr2, chr3;
  let enc1, enc2, enc3, enc4;
  let i2 = 0;
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  while (i2 < input.length) {
    enc1 = _keyStr.indexOf(input.charAt(i2++));
    enc2 = _keyStr.indexOf(input.charAt(i2++));
    enc3 = _keyStr.indexOf(input.charAt(i2++));
    enc4 = _keyStr.indexOf(input.charAt(i2++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output = output + String.fromCharCode(chr1);
    if (enc3 != 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 != 64) {
      output = output + String.fromCharCode(chr3);
    }
  }
  return output;
};

// node_modules/@mui/x-license/utils/licenseScope.js
var LICENSE_SCOPES = ["pro", "premium"];

// node_modules/@mui/x-license/utils/licensingModel.js
var LICENSING_MODELS = [
  /**
   * A license is outdated if the current version of the software was released after the expiry date of the license.
   * But the license can be used indefinitely with an older version of the software.
   */
  "perpetual",
  /**
   * On development, a license is outdated if the expiry date has been reached
   * On production, a license is outdated if the current version of the software was released after the expiry date of the license (see "perpetual")
   */
  "annual",
  /**
   * TODO 2025 remove, legacy name of annual.
   */
  "subscription"
];

// node_modules/@mui/x-license/utils/licenseErrorMessageUtils.js
function showError(message) {
  console.error(["*************************************************************", "", ...message, "", "*************************************************************"].join("\n"));
}
function showInvalidLicenseKeyError() {
  showError(["MUI X: Invalid license key.", "", "Your MUI X license key format isn't valid. It could be because the license key is missing a character or has a typo.", "", "To solve the issue, you need to double check that `setLicenseKey()` is called with the right argument", "Please check the license key installation https://mui.com/r/x-license-key-installation."]);
}
function showLicenseKeyPlanMismatchError() {
  showError(["MUI X: License key plan mismatch.", "", "Your use of MUI X is not compatible with the plan of your license key. The feature you are trying to use is not included in the plan of your license key. This happens if you try to use `DataGridPremium` with a license key for the Pro plan.", "", "To solve the issue, you can upgrade your plan from Pro to Premium at https://mui.com/r/x-get-license?scope=premium.", "Of if you didn't intend to use Premium features, you can replace the import of `@mui/x-data-grid-premium` with `@mui/x-data-grid-pro`."]);
}
function showMissingLicenseKeyError({
  plan,
  packageName
}) {
  showError(["MUI X: Missing license key.", "", `The license key is missing. You might not be allowed to use \`${packageName}\` which is part of MUI X ${plan}.`, "", "To solve the issue, you can check the free trial conditions: https://mui.com/r/x-license-trial.", "If you are eligible no actions are required. If you are not eligible to the free trial, you need to purchase a license https://mui.com/r/x-get-license or stop using the software immediately."]);
}
function showExpiredPackageVersionError({
  packageName
}) {
  showError(["MUI X: Expired package version.", "", `You have installed a version of \`${packageName}\` that is outside of the maintenance plan of your license key. By default, commercial licenses provide access to new versions released during the first year after the purchase.`, "", "To solve the issue, you can renew your license https://mui.com/r/x-get-license or install an older version of the npm package that is compatible with your license key."]);
}
function showExpiredAnnualGraceLicenseKeyError({
  plan,
  licenseKey,
  expiryTimestamp
}) {
  showError(["MUI X: Expired license key.", "", `Your annual license key to use MUI X ${plan} in non-production environments has expired. If you are seeing this development console message, you might be close to breach the license terms by making direct or indirect changes to the frontend of an app that render a MUI X ${plan} component (more details in https://mui.com/r/x-license-annual).`, "", "To solve the problem you can either:", "", "- Renew your license https://mui.com/r/x-get-license and use the new key", `- Stop making changes to code depending directly or indirectly on MUI X ${plan}'s APIs`, "", "Note that your license is perpetual in production environments with any version released before your license term ends.", "", `- License key expiry timestamp: ${new Date(expiryTimestamp)}`, `- Installed license key: ${licenseKey}`, ""]);
}
function showExpiredAnnualLicenseKeyError({
  plan,
  licenseKey,
  expiryTimestamp
}) {
  throw new Error(["MUI X: Expired license key.", "", `Your annual license key to use MUI X ${plan} in non-production environments has expired. If you are seeing this development console message, you might be close to breach the license terms by making direct or indirect changes to the frontend of an app that render a MUI X ${plan} component (more details in https://mui.com/r/x-license-annual).`, "", "To solve the problem you can either:", "", "- Renew your license https://mui.com/r/x-get-license and use the new key", `- Stop making changes to code depending directly or indirectly on MUI X ${plan}'s APIs`, "", "Note that your license is perpetual in production environments with any version released before your license term ends.", "", `- License key expiry timestamp: ${new Date(expiryTimestamp)}`, `- Installed license key: ${licenseKey}`, ""].join("\n"));
}

// node_modules/@mui/x-license/utils/licenseInfo.js
init_utils();
ponyfillGlobal_default.__MUI_LICENSE_INFO__ = ponyfillGlobal_default.__MUI_LICENSE_INFO__ || {
  key: void 0
};
var LicenseInfo = class _LicenseInfo {
  static getLicenseInfo() {
    return ponyfillGlobal_default.__MUI_LICENSE_INFO__;
  }
  static getLicenseKey() {
    return _LicenseInfo.getLicenseInfo().key;
  }
  static setLicenseKey(key) {
    const licenseInfo = _LicenseInfo.getLicenseInfo();
    licenseInfo.key = key;
  }
};

// node_modules/@mui/x-license/utils/licenseStatus.js
var LICENSE_STATUS = function(LICENSE_STATUS2) {
  LICENSE_STATUS2["NotFound"] = "NotFound";
  LICENSE_STATUS2["Invalid"] = "Invalid";
  LICENSE_STATUS2["ExpiredAnnual"] = "ExpiredAnnual";
  LICENSE_STATUS2["ExpiredAnnualGrace"] = "ExpiredAnnualGrace";
  LICENSE_STATUS2["ExpiredVersion"] = "ExpiredVersion";
  LICENSE_STATUS2["Valid"] = "Valid";
  LICENSE_STATUS2["OutOfScope"] = "OutOfScope";
  return LICENSE_STATUS2;
}({});

// node_modules/@mui/x-license/verifyLicense/verifyLicense.js
var expiryReg = /^.*EXPIRY=([0-9]+),.*$/;
var decodeLicenseVersion1 = (license) => {
  let expiryTimestamp;
  try {
    expiryTimestamp = parseInt(license.match(expiryReg)[1], 10);
    if (!expiryTimestamp || Number.isNaN(expiryTimestamp)) {
      expiryTimestamp = null;
    }
  } catch (err) {
    expiryTimestamp = null;
  }
  return {
    scope: "pro",
    licensingModel: "perpetual",
    expiryTimestamp
  };
};
var decodeLicenseVersion2 = (license) => {
  const licenseInfo = {
    scope: null,
    licensingModel: null,
    expiryTimestamp: null
  };
  license.split(",").map((token) => token.split("=")).filter((el) => el.length === 2).forEach(([key, value]) => {
    if (key === "S") {
      licenseInfo.scope = value;
    }
    if (key === "LM") {
      licenseInfo.licensingModel = value;
    }
    if (key === "E") {
      const expiryTimestamp = parseInt(value, 10);
      if (expiryTimestamp && !Number.isNaN(expiryTimestamp)) {
        licenseInfo.expiryTimestamp = expiryTimestamp;
      }
    }
  });
  return licenseInfo;
};
var decodeLicense = (encodedLicense) => {
  const license = base64Decode(encodedLicense);
  if (license.includes("KEYVERSION=1")) {
    return decodeLicenseVersion1(license);
  }
  if (license.includes("KV=2")) {
    return decodeLicenseVersion2(license);
  }
  return null;
};
function verifyLicense({
  releaseInfo: releaseInfo2,
  licenseKey,
  acceptedScopes
}) {
  if (!releaseInfo2) {
    throw new Error("MUI X: The release information is missing. Not able to validate license.");
  }
  if (!licenseKey) {
    return {
      status: LICENSE_STATUS.NotFound
    };
  }
  const hash = licenseKey.substr(0, 32);
  const encoded = licenseKey.substr(32);
  if (hash !== md5(encoded)) {
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  const license = decodeLicense(encoded);
  if (license == null) {
    console.error("MUI X: Error checking license. Key version not found!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.licensingModel == null || !LICENSING_MODELS.includes(license.licensingModel)) {
    console.error("MUI X: Error checking license. Licensing model not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.expiryTimestamp == null) {
    console.error("MUI X: Error checking license. Expiry timestamp not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.licensingModel === "perpetual" || false) {
    const pkgTimestamp = parseInt(base64Decode(releaseInfo2), 10);
    if (Number.isNaN(pkgTimestamp)) {
      throw new Error("MUI X: The release information is invalid. Not able to validate license.");
    }
    if (license.expiryTimestamp < pkgTimestamp) {
      return {
        status: LICENSE_STATUS.ExpiredVersion
      };
    }
  } else if (license.licensingModel === "subscription" || license.licensingModel === "annual") {
    if ((/* @__PURE__ */ new Date()).getTime() > license.expiryTimestamp) {
      if (
        // 30 days grace
        (/* @__PURE__ */ new Date()).getTime() < license.expiryTimestamp + 1e3 * 3600 * 24 * 30 || false
      ) {
        return {
          status: LICENSE_STATUS.ExpiredAnnualGrace,
          meta: {
            expiryTimestamp: license.expiryTimestamp,
            licenseKey
          }
        };
      }
      return {
        status: LICENSE_STATUS.ExpiredAnnual,
        meta: {
          expiryTimestamp: license.expiryTimestamp,
          licenseKey
        }
      };
    }
  }
  if (license.scope == null || !LICENSE_SCOPES.includes(license.scope)) {
    console.error("Error checking license. scope not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (!acceptedScopes.includes(license.scope)) {
    return {
      status: LICENSE_STATUS.OutOfScope
    };
  }
  return {
    status: LICENSE_STATUS.Valid
  };
}

// node_modules/@mui/x-license/useLicenseVerifier/useLicenseVerifier.js
init_extends();
var React2 = __toESM(require_react());

// node_modules/@mui/x-license/Unstable_LicenseInfoProvider/MuiLicenseInfoContext.js
var React = __toESM(require_react());
var MuiLicenseInfoContext = React.createContext({
  key: void 0
});
if (true) {
  MuiLicenseInfoContext.displayName = "MuiLicenseInfoContext";
}
var MuiLicenseInfoContext_default = MuiLicenseInfoContext;

// node_modules/@mui/x-license/useLicenseVerifier/useLicenseVerifier.js
var sharedLicenseStatuses = {};
function useLicenseVerifier(packageName, releaseInfo2) {
  const {
    key: contextKey
  } = React2.useContext(MuiLicenseInfoContext_default);
  return React2.useMemo(() => {
    const licenseKey = contextKey ?? LicenseInfo.getLicenseKey();
    if (sharedLicenseStatuses[packageName] && sharedLicenseStatuses[packageName].key === licenseKey) {
      return sharedLicenseStatuses[packageName].licenseVerifier;
    }
    const acceptedScopes = packageName.includes("premium") ? ["premium"] : ["pro", "premium"];
    const plan = packageName.includes("premium") ? "Premium" : "Pro";
    const licenseStatus = verifyLicense({
      releaseInfo: releaseInfo2,
      licenseKey,
      acceptedScopes
    });
    const fullPackageName = `@mui/${packageName}`;
    if (licenseStatus.status === LICENSE_STATUS.Valid) {
    } else if (licenseStatus.status === LICENSE_STATUS.Invalid) {
      showInvalidLicenseKeyError();
    } else if (licenseStatus.status === LICENSE_STATUS.OutOfScope) {
      showLicenseKeyPlanMismatchError();
    } else if (licenseStatus.status === LICENSE_STATUS.NotFound) {
      showMissingLicenseKeyError({
        plan,
        packageName: fullPackageName
      });
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredAnnualGrace) {
      showExpiredAnnualGraceLicenseKeyError(_extends({
        plan
      }, licenseStatus.meta));
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredAnnual) {
      showExpiredAnnualLicenseKeyError(_extends({
        plan
      }, licenseStatus.meta));
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredVersion) {
      showExpiredPackageVersionError({
        packageName: fullPackageName
      });
    } else if (true) {
      throw new Error("missing status handler");
    }
    sharedLicenseStatuses[packageName] = {
      key: licenseKey,
      licenseVerifier: licenseStatus
    };
    return licenseStatus;
  }, [packageName, releaseInfo2, contextKey]);
}

// node_modules/@mui/x-license/Watermark/Watermark.js
var React3 = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
function getLicenseErrorMessage(licenseStatus) {
  switch (licenseStatus) {
    case LICENSE_STATUS.ExpiredAnnualGrace:
    case LICENSE_STATUS.ExpiredAnnual:
      return "MUI X Expired license key";
    case LICENSE_STATUS.ExpiredVersion:
      return "MUI X Expired package version";
    case LICENSE_STATUS.Invalid:
      return "MUI X Invalid license key";
    case LICENSE_STATUS.OutOfScope:
      return "MUI X License key plan mismatch";
    case LICENSE_STATUS.NotFound:
      return "MUI X Missing license key";
    default:
      throw new Error("Unhandled MUI X license status.");
  }
}
function Watermark(props) {
  const {
    packageName,
    releaseInfo: releaseInfo2
  } = props;
  const licenseStatus = useLicenseVerifier(packageName, releaseInfo2);
  if (licenseStatus.status === LICENSE_STATUS.Valid) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)("div", {
    style: {
      position: "absolute",
      pointerEvents: "none",
      color: "#8282829e",
      zIndex: 1e5,
      width: "100%",
      textAlign: "center",
      bottom: "50%",
      right: 0,
      letterSpacing: 5,
      fontSize: 24
    },
    children: getLicenseErrorMessage(licenseStatus.status)
  });
}

// node_modules/@mui/x-license/Unstable_LicenseInfoProvider/LicenseInfoProvider.js
var React4 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());

// node_modules/@mui/x-data-grid-pro/esm/DataGridPro/DataGrid.js
function DataGrid() {
  if (false) {
    return null;
  }
  throw new Error(["You try to import `DataGrid` from @mui/x-data-grid-pro but this module doesn't exist.", "", "Instead, you can do `import { DataGridPro } from '@mui/x-data-grid-pro'`."].join("\n"));
}
function DataGridPremium() {
  if (false) {
    return null;
  }
  throw new Error(["You try to import `DataGridPremium` from @mui/x-data-grid-pro but this module doesn't exist.", "", "Instead, you can do `import { DataGridPro } from '@mui/x-data-grid-pro'`."].join("\n"));
}

// node_modules/@mui/x-data-grid-pro/esm/DataGridPro/DataGridPro.js
init_extends();
var React37 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());

// node_modules/@mui/x-data-grid/hooks/features/headerFiltering/useGridHeaderFiltering.js
init_extends();
var React5 = __toESM(require_react());
var headerFilteringStateInitializer = (state, props) => _extends({}, state, {
  headerFiltering: {
    enabled: props.headerFilters ?? false,
    editing: null,
    menuOpen: null
  }
});
var useGridHeaderFiltering = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridHeaderFiltering");
  const setHeaderFilterState = React5.useCallback((headerFilterState) => {
    apiRef.current.setState((state) => {
      if (props.signature === "DataGrid") {
        return state;
      }
      return _extends({}, state, {
        headerFiltering: {
          enabled: props.headerFilters ?? false,
          editing: headerFilterState.editing ?? null,
          menuOpen: headerFilterState.menuOpen ?? null
        }
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef, props.signature, props.headerFilters]);
  const startHeaderFilterEditMode = React5.useCallback((field) => {
    logger.debug(`Starting edit mode on header filter for field: ${field}`);
    apiRef.current.setHeaderFilterState({
      editing: field
    });
  }, [apiRef, logger]);
  const stopHeaderFilterEditMode = React5.useCallback(() => {
    logger.debug(`Stopping edit mode on header filter`);
    apiRef.current.setHeaderFilterState({
      editing: null
    });
  }, [apiRef, logger]);
  const showHeaderFilterMenu = React5.useCallback((field) => {
    logger.debug(`Opening header filter menu for field: ${field}`);
    apiRef.current.setHeaderFilterState({
      menuOpen: field
    });
  }, [apiRef, logger]);
  const hideHeaderFilterMenu = React5.useCallback(() => {
    logger.debug(`Hiding header filter menu for active field`);
    let fieldToFocus = apiRef.current.state.headerFiltering.menuOpen;
    if (fieldToFocus) {
      const columnLookup = gridColumnLookupSelector(apiRef);
      const columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef);
      const orderedFields = gridColumnFieldsSelector(apiRef);
      if (!columnLookup[fieldToFocus]) {
        fieldToFocus = orderedFields[0];
      }
      if (columnVisibilityModel[fieldToFocus] === false) {
        const visibleOrderedFields = orderedFields.filter((field) => {
          if (field === fieldToFocus) {
            return true;
          }
          return columnVisibilityModel[field] !== false;
        });
        const fieldIndex = visibleOrderedFields.indexOf(fieldToFocus);
        fieldToFocus = visibleOrderedFields[fieldIndex + 1] || visibleOrderedFields[fieldIndex - 1];
      }
      apiRef.current.setHeaderFilterState({
        menuOpen: null
      });
      apiRef.current.setColumnHeaderFilterFocus(fieldToFocus);
    }
  }, [apiRef, logger]);
  const headerFilterPrivateApi = {
    setHeaderFilterState
  };
  const headerFilterApi = {
    startHeaderFilterEditMode,
    stopHeaderFilterEditMode,
    showHeaderFilterMenu,
    hideHeaderFilterMenu
  };
  useGridApiMethod(apiRef, headerFilterApi, "public");
  useGridApiMethod(apiRef, headerFilterPrivateApi, "private");
  const isFirstRender = React5.useRef(true);
  React5.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    } else {
      apiRef.current.setHeaderFilterState({
        enabled: props.headerFilters ?? false
      });
    }
  }, [apiRef, props.headerFilters]);
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/infiniteLoader/useGridInfiniteLoader.js
var React6 = __toESM(require_react());
init_useEventCallback();
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var InfiniteLoadingTriggerElement = styled_default2("div")({
  position: "sticky",
  left: 0,
  width: 0,
  height: 0
});
var useGridInfiniteLoader = (apiRef, props) => {
  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);
  const currentPage = useGridVisibleRows(apiRef, props);
  const observer = React6.useRef();
  const triggerElement = React6.useRef(null);
  const isEnabled = props.rowsLoadingMode === "client" && !!props.onRowsScrollEnd;
  const handleLoadMoreRows = useEventCallback_default(([entry]) => {
    var _a;
    const currentRatio = entry.intersectionRatio;
    const isIntersecting = entry.isIntersecting;
    if (isIntersecting && currentRatio === 1) {
      const viewportPageSize = apiRef.current.getViewportPageSize();
      const rowScrollEndParams = {
        visibleColumns,
        viewportPageSize,
        visibleRowsCount: currentPage.rows.length
      };
      apiRef.current.publishEvent("rowsScrollEnd", rowScrollEndParams);
      (_a = observer.current) == null ? void 0 : _a.disconnect();
      triggerElement.current = null;
    }
  });
  const virtualScroller = apiRef.current.virtualScrollerRef.current;
  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);
  const marginBottom = props.scrollEndThreshold - (dimensions.hasScrollX ? dimensions.scrollbarSize : 0);
  React6.useEffect(() => {
    var _a;
    if (!isEnabled) {
      return;
    }
    if (!virtualScroller) {
      return;
    }
    (_a = observer.current) == null ? void 0 : _a.disconnect();
    observer.current = new IntersectionObserver(handleLoadMoreRows, {
      threshold: 1,
      root: virtualScroller,
      rootMargin: `0px 0px ${marginBottom}px 0px`
    });
    if (triggerElement.current) {
      observer.current.observe(triggerElement.current);
    }
  }, [virtualScroller, handleLoadMoreRows, isEnabled, marginBottom]);
  const triggerRef = React6.useCallback((node) => {
    var _a, _b;
    if (!isEnabled) {
      return;
    }
    if (triggerElement.current !== node) {
      (_a = observer.current) == null ? void 0 : _a.disconnect();
      triggerElement.current = node;
      if (triggerElement.current) {
        (_b = observer.current) == null ? void 0 : _b.observe(triggerElement.current);
      }
    }
  }, [isEnabled]);
  const getInfiniteLoadingTriggerElement = React6.useCallback(({
    lastRowId
  }) => {
    if (!isEnabled) {
      return null;
    }
    return (0, import_jsx_runtime3.jsx)(InfiniteLoadingTriggerElement, {
      ref: triggerRef,
      role: "presentation"
    }, `trigger-${lastRowId}`);
  }, [isEnabled, triggerRef]);
  const infiniteLoaderPrivateApi = {
    getInfiniteLoadingTriggerElement
  };
  useGridApiMethod(apiRef, infiniteLoaderPrivateApi, "private");
  useGridApiOptionHandler(apiRef, "rowsScrollEnd", props.onRowsScrollEnd);
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/columnReorder/useGridColumnReorder.js
init_extends();
var React7 = __toESM(require_react());
init_utils();

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/columnReorder/columnReorderSelector.js
var gridColumnReorderSelector = (state) => state.columnReorder;
var gridColumnReorderDragColSelector = createSelector(gridColumnReorderSelector, (columnReorder) => columnReorder.dragCol);

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/columnReorder/useGridColumnReorder.js
var CURSOR_MOVE_DIRECTION_LEFT = "left";
var CURSOR_MOVE_DIRECTION_RIGHT = "right";
var getCursorMoveDirectionX = (currentCoordinates, nextCoordinates) => {
  return currentCoordinates.x <= nextCoordinates.x ? CURSOR_MOVE_DIRECTION_RIGHT : CURSOR_MOVE_DIRECTION_LEFT;
};
var hasCursorPositionChanged = (currentCoordinates, nextCoordinates) => currentCoordinates.x !== nextCoordinates.x || currentCoordinates.y !== nextCoordinates.y;
var useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    columnHeaderDragging: ["columnHeader--dragging"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
var columnReorderStateInitializer = (state) => _extends({}, state, {
  columnReorder: {
    dragCol: ""
  }
});
var useGridColumnReorder = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridColumnReorder");
  const dragColNode = React7.useRef(null);
  const cursorPosition = React7.useRef({
    x: 0,
    y: 0
  });
  const originColumnIndex = React7.useRef(null);
  const forbiddenIndexes = React7.useRef({});
  const removeDnDStylesTimeout = React7.useRef();
  const ownerState = {
    classes: props.classes
  };
  const classes = useUtilityClasses(ownerState);
  const theme = useTheme();
  React7.useEffect(() => {
    return () => {
      clearTimeout(removeDnDStylesTimeout.current);
    };
  }, []);
  const handleDragStart = React7.useCallback((params, event) => {
    if (props.disableColumnReorder || params.colDef.disableReorder) {
      return;
    }
    logger.debug(`Start dragging col ${params.field}`);
    event.stopPropagation();
    dragColNode.current = event.currentTarget;
    dragColNode.current.classList.add(classes.columnHeaderDragging);
    if (event.dataTransfer) {
      event.dataTransfer.effectAllowed = "move";
    }
    apiRef.current.setState((state) => _extends({}, state, {
      columnReorder: _extends({}, state.columnReorder, {
        dragCol: params.field
      })
    }));
    apiRef.current.forceUpdate();
    removeDnDStylesTimeout.current = setTimeout(() => {
      dragColNode.current.classList.remove(classes.columnHeaderDragging);
    });
    originColumnIndex.current = apiRef.current.getColumnIndex(params.field, false);
    const draggingColumnGroupPath = apiRef.current.getColumnGroupPath(params.field);
    const columnIndex = originColumnIndex.current;
    const allColumns = apiRef.current.getAllColumns();
    const groupsLookup = apiRef.current.getAllGroupDetails();
    const getGroupPathFromColumnIndex = (colIndex) => {
      const field = allColumns[colIndex].field;
      return apiRef.current.getColumnGroupPath(field);
    };
    let limitingGroupId = null;
    draggingColumnGroupPath.forEach((groupId) => {
      var _a;
      if (!((_a = groupsLookup[groupId]) == null ? void 0 : _a.freeReordering)) {
        if (columnIndex > 0 && getGroupPathFromColumnIndex(columnIndex - 1).includes(groupId)) {
          limitingGroupId = groupId;
        } else if (columnIndex + 1 < allColumns.length && getGroupPathFromColumnIndex(columnIndex + 1).includes(groupId)) {
          limitingGroupId = groupId;
        }
      }
    });
    forbiddenIndexes.current = {};
    for (let indexToForbid = 0; indexToForbid < allColumns.length; indexToForbid += 1) {
      const leftIndex = indexToForbid <= columnIndex ? indexToForbid - 1 : indexToForbid;
      const rightIndex = indexToForbid < columnIndex ? indexToForbid : indexToForbid + 1;
      if (limitingGroupId !== null) {
        let allowIndex = false;
        if (leftIndex >= 0 && getGroupPathFromColumnIndex(leftIndex).includes(limitingGroupId)) {
          allowIndex = true;
        } else if (rightIndex < allColumns.length && getGroupPathFromColumnIndex(rightIndex).includes(limitingGroupId)) {
          allowIndex = true;
        }
        if (!allowIndex) {
          forbiddenIndexes.current[indexToForbid] = true;
        }
      }
      if (leftIndex >= 0 && rightIndex < allColumns.length) {
        getGroupPathFromColumnIndex(rightIndex).forEach((groupId) => {
          var _a;
          if (getGroupPathFromColumnIndex(leftIndex).includes(groupId)) {
            if (!draggingColumnGroupPath.includes(groupId)) {
              if (!((_a = groupsLookup[groupId]) == null ? void 0 : _a.freeReordering)) {
                forbiddenIndexes.current[indexToForbid] = true;
              }
            }
          }
        });
      }
    }
  }, [props.disableColumnReorder, classes.columnHeaderDragging, logger, apiRef]);
  const handleDragEnter = React7.useCallback((params, event) => {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  const handleDragOver = React7.useCallback((params, event) => {
    const dragColField = gridColumnReorderDragColSelector(apiRef);
    if (!dragColField) {
      return;
    }
    logger.debug(`Dragging over col ${params.field}`);
    event.preventDefault();
    event.stopPropagation();
    const coordinates = {
      x: event.clientX,
      y: event.clientY
    };
    if (params.field !== dragColField && hasCursorPositionChanged(cursorPosition.current, coordinates)) {
      const targetColIndex = apiRef.current.getColumnIndex(params.field, false);
      const targetColVisibleIndex = apiRef.current.getColumnIndex(params.field, true);
      const targetCol = apiRef.current.getColumn(params.field);
      const dragColIndex = apiRef.current.getColumnIndex(dragColField, false);
      const visibleColumns = apiRef.current.getVisibleColumns();
      const allColumns = apiRef.current.getAllColumns();
      const cursorMoveDirectionX = getCursorMoveDirectionX(cursorPosition.current, coordinates);
      const hasMovedLeft = cursorMoveDirectionX === CURSOR_MOVE_DIRECTION_LEFT && (theme.direction === "rtl" ? dragColIndex < targetColIndex : targetColIndex < dragColIndex);
      const hasMovedRight = cursorMoveDirectionX === CURSOR_MOVE_DIRECTION_RIGHT && (theme.direction === "rtl" ? targetColIndex < dragColIndex : dragColIndex < targetColIndex);
      if (hasMovedLeft || hasMovedRight) {
        let canBeReordered;
        let indexOffsetInHiddenColumns = 0;
        if (!targetCol.disableReorder) {
          canBeReordered = true;
        } else if (hasMovedLeft) {
          canBeReordered = targetColVisibleIndex > 0 && !visibleColumns[targetColVisibleIndex - 1].disableReorder;
        } else {
          canBeReordered = targetColVisibleIndex < visibleColumns.length - 1 && !visibleColumns[targetColVisibleIndex + 1].disableReorder;
        }
        if (forbiddenIndexes.current[targetColIndex]) {
          let nextVisibleColumnField;
          let indexWithOffset = targetColIndex + indexOffsetInHiddenColumns;
          if (hasMovedLeft) {
            nextVisibleColumnField = targetColVisibleIndex > 0 ? visibleColumns[targetColVisibleIndex - 1].field : null;
            while (indexWithOffset > 0 && allColumns[indexWithOffset].field !== nextVisibleColumnField && forbiddenIndexes.current[indexWithOffset]) {
              indexOffsetInHiddenColumns -= 1;
              indexWithOffset = targetColIndex + indexOffsetInHiddenColumns;
            }
          } else {
            nextVisibleColumnField = targetColVisibleIndex + 1 < visibleColumns.length ? visibleColumns[targetColVisibleIndex + 1].field : null;
            while (indexWithOffset < allColumns.length - 1 && allColumns[indexWithOffset].field !== nextVisibleColumnField && forbiddenIndexes.current[indexWithOffset]) {
              indexOffsetInHiddenColumns += 1;
              indexWithOffset = targetColIndex + indexOffsetInHiddenColumns;
            }
          }
          if (forbiddenIndexes.current[indexWithOffset] || allColumns[indexWithOffset].field === nextVisibleColumnField) {
            canBeReordered = false;
          }
        }
        const canBeReorderedProcessed = apiRef.current.unstable_applyPipeProcessors("canBeReordered", canBeReordered, {
          targetIndex: targetColVisibleIndex
        });
        if (canBeReorderedProcessed) {
          apiRef.current.setColumnIndex(dragColField, targetColIndex + indexOffsetInHiddenColumns);
        }
      }
      cursorPosition.current = coordinates;
    }
  }, [apiRef, logger, theme.direction]);
  const handleDragEnd = React7.useCallback((params, event) => {
    const dragColField = gridColumnReorderDragColSelector(apiRef);
    if (props.disableColumnReorder || !dragColField) {
      return;
    }
    logger.debug("End dragging col");
    event.preventDefault();
    event.stopPropagation();
    clearTimeout(removeDnDStylesTimeout.current);
    dragColNode.current = null;
    if (event.dataTransfer.dropEffect === "none" && !props.keepColumnPositionIfDraggedOutside) {
      apiRef.current.setColumnIndex(dragColField, originColumnIndex.current);
      originColumnIndex.current = null;
    } else {
      const columnOrderChangeParams = {
        column: apiRef.current.getColumn(dragColField),
        targetIndex: apiRef.current.getColumnIndexRelativeToVisibleColumns(dragColField),
        oldIndex: originColumnIndex.current
      };
      apiRef.current.publishEvent("columnOrderChange", columnOrderChangeParams);
    }
    apiRef.current.setState((state) => _extends({}, state, {
      columnReorder: _extends({}, state.columnReorder, {
        dragCol: ""
      })
    }));
    apiRef.current.forceUpdate();
  }, [props.disableColumnReorder, props.keepColumnPositionIfDraggedOutside, logger, apiRef]);
  useGridApiEventHandler(apiRef, "columnHeaderDragStart", handleDragStart);
  useGridApiEventHandler(apiRef, "columnHeaderDragEnter", handleDragEnter);
  useGridApiEventHandler(apiRef, "columnHeaderDragOver", handleDragOver);
  useGridApiEventHandler(apiRef, "columnHeaderDragEnd", handleDragEnd);
  useGridApiEventHandler(apiRef, "cellDragEnter", handleDragEnter);
  useGridApiEventHandler(apiRef, "cellDragOver", handleDragOver);
  useGridApiOptionHandler(apiRef, "columnOrderChange", props.onColumnOrderChange);
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/treeData/useGridTreeData.js
var React8 = __toESM(require_react());

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/treeData/gridTreeDataGroupColDef.js
init_extends();
var GRID_TREE_DATA_GROUPING_COL_DEF = _extends({}, GRID_STRING_COL_DEF, {
  type: "custom",
  sortable: false,
  filterable: false,
  disableColumnMenu: true,
  disableReorder: true,
  align: "left",
  width: 200,
  valueGetter: (value, row, column, apiRef) => {
    const rowId = apiRef.current.getRowId(row);
    const rowNode = apiRef.current.getRowNode(rowId);
    return (rowNode == null ? void 0 : rowNode.type) === "group" || (rowNode == null ? void 0 : rowNode.type) === "leaf" ? rowNode.groupingKey : void 0;
  }
});
var GRID_TREE_DATA_GROUPING_FIELD = "__tree_data_group__";
var GRID_TREE_DATA_GROUPING_COL_DEF_FORCED_PROPERTIES = {
  field: GRID_TREE_DATA_GROUPING_FIELD,
  editable: false,
  groupable: false
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/treeData/useGridTreeData.js
var useGridTreeData = (apiRef) => {
  const handleCellKeyDown = React8.useCallback((params, event) => {
    const cellParams = apiRef.current.getCellParams(params.id, params.field);
    if (cellParams.colDef.field === GRID_TREE_DATA_GROUPING_FIELD && event.key === " " && !event.shiftKey) {
      if (params.rowNode.type !== "group") {
        return;
      }
      apiRef.current.setRowChildrenExpansion(params.id, !params.rowNode.childrenExpanded);
    }
  }, [apiRef]);
  useGridApiEventHandler(apiRef, "cellKeyDown", handleCellKeyDown);
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/treeData/useGridTreeDataPreProcessors.js
init_extends();
init_objectWithoutPropertiesLoose();
var React17 = __toESM(require_react());

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/treeData/gridTreeDataUtils.js
var TREE_DATA_STRATEGY = "tree-data";
var filterRowTreeFromTreeData = (params) => {
  const {
    apiRef,
    rowTree,
    disableChildrenFiltering,
    isRowMatchingFilters
  } = params;
  const filteredRowsLookup = {};
  const filteredDescendantCountLookup = {};
  const filterCache = {};
  const filterResults = {
    passingFilterItems: null,
    passingQuickFilterValues: null
  };
  const filterTreeNode = (node, isParentMatchingFilters, areAncestorsExpanded) => {
    const shouldSkipFilters = disableChildrenFiltering && node.depth > 0;
    let isMatchingFilters;
    if (shouldSkipFilters) {
      isMatchingFilters = null;
    } else if (!isRowMatchingFilters || node.type === "footer") {
      isMatchingFilters = true;
    } else {
      const row = apiRef.current.getRow(node.id);
      isRowMatchingFilters(row, void 0, filterResults);
      isMatchingFilters = passFilterLogic([filterResults.passingFilterItems], [filterResults.passingQuickFilterValues], params.filterModel, params.apiRef, filterCache);
    }
    let filteredDescendantCount = 0;
    if (node.type === "group") {
      node.children.forEach((childId) => {
        const childNode = rowTree[childId];
        const childSubTreeSize = filterTreeNode(childNode, isMatchingFilters ?? isParentMatchingFilters, areAncestorsExpanded && !!node.childrenExpanded);
        filteredDescendantCount += childSubTreeSize;
      });
    }
    let shouldPassFilters;
    switch (isMatchingFilters) {
      case true: {
        shouldPassFilters = true;
        break;
      }
      case false: {
        shouldPassFilters = filteredDescendantCount > 0;
        break;
      }
      default: {
        shouldPassFilters = isParentMatchingFilters;
        break;
      }
    }
    filteredRowsLookup[node.id] = shouldPassFilters;
    if (!shouldPassFilters) {
      return 0;
    }
    filteredDescendantCountLookup[node.id] = filteredDescendantCount;
    if (node.type === "footer") {
      return filteredDescendantCount;
    }
    return filteredDescendantCount + 1;
  };
  const nodes = Object.values(rowTree);
  for (let i2 = 0; i2 < nodes.length; i2 += 1) {
    const node = nodes[i2];
    if (node.depth === 0) {
      filterTreeNode(node, true, true);
    }
  }
  return {
    filteredRowsLookup,
    filteredDescendantCountLookup
  };
};

// node_modules/@mui/x-data-grid-pro/esm/components/GridTreeDataGroupingCell.js
init_extends();
var React9 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-data-grid-pro/esm/hooks/utils/useGridRootProps.js
var useGridRootProps2 = useGridRootProps;

// node_modules/@mui/x-data-grid-pro/esm/hooks/utils/useGridApiContext.js
var useGridApiContext2 = useGridApiContext;

// node_modules/@mui/x-data-grid-pro/esm/components/GridTreeDataGroupingCell.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var useUtilityClasses2 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["treeDataGroupingCell"],
    toggle: ["treeDataGroupingCellToggle"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function GridTreeDataGroupingCell(props) {
  var _a;
  const {
    id,
    field,
    formattedValue,
    rowNode,
    hideDescendantCount,
    offsetMultiplier = 2
  } = props;
  const rootProps = useGridRootProps2();
  const apiRef = useGridApiContext2();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes = useUtilityClasses2(ownerState);
  const filteredDescendantCountLookup = useGridSelector(apiRef, gridFilteredDescendantCountLookupSelector);
  const filteredDescendantCount = filteredDescendantCountLookup[rowNode.id] ?? 0;
  const Icon = rowNode.childrenExpanded ? rootProps.slots.treeDataCollapseIcon : rootProps.slots.treeDataExpandIcon;
  const handleClick = (event) => {
    apiRef.current.setRowChildrenExpansion(id, !rowNode.childrenExpanded);
    apiRef.current.setCellFocus(id, field);
    event.stopPropagation();
  };
  return (0, import_jsx_runtime4.jsxs)(Box_default, {
    className: classes.root,
    sx: {
      ml: rowNode.depth * offsetMultiplier
    },
    children: [(0, import_jsx_runtime4.jsx)("div", {
      className: classes.toggle,
      children: filteredDescendantCount > 0 && (0, import_jsx_runtime4.jsx)(rootProps.slots.baseIconButton, _extends({
        size: "small",
        onClick: handleClick,
        tabIndex: -1,
        "aria-label": rowNode.childrenExpanded ? apiRef.current.getLocaleText("treeDataCollapse") : apiRef.current.getLocaleText("treeDataExpand")
      }, (_a = rootProps == null ? void 0 : rootProps.slotProps) == null ? void 0 : _a.baseIconButton, {
        children: (0, import_jsx_runtime4.jsx)(Icon, {
          fontSize: "inherit"
        })
      }))
    }), (0, import_jsx_runtime4.jsxs)("span", {
      children: [formattedValue === void 0 ? rowNode.groupingKey : formattedValue, !hideDescendantCount && filteredDescendantCount > 0 ? ` (${filteredDescendantCount})` : ""]
    })]
  });
}
true ? GridTreeDataGroupingCell.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * GridApi that let you manipulate the grid.
   */
  api: import_prop_types.default.object.isRequired,
  /**
   * The mode of the cell.
   */
  cellMode: import_prop_types.default.oneOf(["edit", "view"]).isRequired,
  /**
   * The column of the row that the current cell belongs to.
   */
  colDef: import_prop_types.default.object.isRequired,
  /**
   * The column field of the cell that triggered the event.
   */
  field: import_prop_types.default.string.isRequired,
  /**
   * A ref allowing to set imperative focus.
   * It can be passed to the element that should receive focus.
   * @ignore - do not document.
   */
  focusElementRef: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.shape({
    current: import_prop_types.default.shape({
      focus: import_prop_types.default.func.isRequired
    })
  })]),
  /**
   * The cell value formatted with the column valueFormatter.
   */
  formattedValue: import_prop_types.default.any,
  /**
   * If true, the cell is the active element.
   */
  hasFocus: import_prop_types.default.bool.isRequired,
  hideDescendantCount: import_prop_types.default.bool,
  /**
   * The grid row id.
   */
  id: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]).isRequired,
  /**
   * If true, the cell is editable.
   */
  isEditable: import_prop_types.default.bool,
  /**
   * The cell offset multiplier used for calculating cell offset (`rowNode.depth * offsetMultiplier` px).
   * @default 2
   */
  offsetMultiplier: import_prop_types.default.number,
  /**
   * The row model of the row that the current cell belongs to.
   */
  row: import_prop_types.default.any.isRequired,
  /**
   * The node of the row that the current cell belongs to.
   */
  rowNode: import_prop_types.default.object.isRequired,
  /**
   * the tabIndex value.
   */
  tabIndex: import_prop_types.default.oneOf([-1, 0]).isRequired,
  /**
   * The cell value.
   * If the column has `valueGetter`, use `params.row` to directly access the fields.
   */
  value: import_prop_types.default.any
} : void 0;

// node_modules/@mui/x-data-grid-pro/esm/components/GridColumnMenuPinningItem.js
var React10 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
function GridColumnMenuPinningItem(props) {
  const {
    colDef,
    onClick
  } = props;
  const apiRef = useGridApiContext2();
  const rootProps = useGridRootProps2();
  const theme = useTheme();
  const pinColumn = React10.useCallback((side2) => (event) => {
    apiRef.current.pinColumn(colDef.field, side2);
    onClick(event);
  }, [apiRef, colDef.field, onClick]);
  const unpinColumn = (event) => {
    apiRef.current.unpinColumn(colDef.field);
    onClick(event);
  };
  const pinToLeftMenuItem = (0, import_jsx_runtime5.jsxs)(MenuItem_default, {
    onClick: pinColumn(GridPinnedColumnPosition.LEFT),
    children: [(0, import_jsx_runtime5.jsx)(ListItemIcon_default, {
      children: (0, import_jsx_runtime5.jsx)(rootProps.slots.columnMenuPinLeftIcon, {
        fontSize: "small"
      })
    }), (0, import_jsx_runtime5.jsx)(ListItemText_default, {
      children: apiRef.current.getLocaleText("pinToLeft")
    })]
  });
  const pinToRightMenuItem = (0, import_jsx_runtime5.jsxs)(MenuItem_default, {
    onClick: pinColumn(GridPinnedColumnPosition.RIGHT),
    children: [(0, import_jsx_runtime5.jsx)(ListItemIcon_default, {
      children: (0, import_jsx_runtime5.jsx)(rootProps.slots.columnMenuPinRightIcon, {
        fontSize: "small"
      })
    }), (0, import_jsx_runtime5.jsx)(ListItemText_default, {
      children: apiRef.current.getLocaleText("pinToRight")
    })]
  });
  if (!colDef) {
    return null;
  }
  const side = apiRef.current.isColumnPinned(colDef.field);
  if (side) {
    const otherSide = side === GridPinnedColumnPosition.RIGHT ? GridPinnedColumnPosition.LEFT : GridPinnedColumnPosition.RIGHT;
    const label = otherSide === GridPinnedColumnPosition.RIGHT ? "pinToRight" : "pinToLeft";
    const Icon = side === GridPinnedColumnPosition.RIGHT ? rootProps.slots.columnMenuPinLeftIcon : rootProps.slots.columnMenuPinRightIcon;
    return (0, import_jsx_runtime5.jsxs)(React10.Fragment, {
      children: [(0, import_jsx_runtime5.jsxs)(MenuItem_default, {
        onClick: pinColumn(otherSide),
        children: [(0, import_jsx_runtime5.jsx)(ListItemIcon_default, {
          children: (0, import_jsx_runtime5.jsx)(Icon, {
            fontSize: "small"
          })
        }), (0, import_jsx_runtime5.jsx)(ListItemText_default, {
          children: apiRef.current.getLocaleText(label)
        })]
      }), (0, import_jsx_runtime5.jsxs)(MenuItem_default, {
        onClick: unpinColumn,
        children: [(0, import_jsx_runtime5.jsx)(ListItemIcon_default, {}), (0, import_jsx_runtime5.jsx)(ListItemText_default, {
          children: apiRef.current.getLocaleText("unpin")
        })]
      })]
    });
  }
  if (theme.direction === "rtl") {
    return (0, import_jsx_runtime5.jsxs)(React10.Fragment, {
      children: [pinToRightMenuItem, pinToLeftMenuItem]
    });
  }
  return (0, import_jsx_runtime5.jsxs)(React10.Fragment, {
    children: [pinToLeftMenuItem, pinToRightMenuItem]
  });
}
true ? GridColumnMenuPinningItem.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  colDef: import_prop_types2.default.object.isRequired,
  onClick: import_prop_types2.default.func.isRequired
} : void 0;

// node_modules/@mui/x-data-grid-pro/esm/components/GridDetailPanelToggleCell.js
init_extends();
var React11 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/detailPanel/gridDetailPanelSelector.js
var gridDetailPanelExpandedRowIdsSelector = (state) => state.detailPanel.expandedRowIds;
var gridDetailPanelExpandedRowsContentCacheSelector = (state) => state.detailPanel.contentCache;
var gridDetailPanelRawHeightCacheSelector = (state) => state.detailPanel.heightCache;
var gridDetailPanelExpandedRowsHeightCacheSelector = createSelectorMemoized(gridDetailPanelRawHeightCacheSelector, (heightCache) => Object.entries(heightCache).reduce((acc, [id, {
  height
}]) => {
  acc[id] = height || 0;
  return acc;
}, {}));

// node_modules/@mui/x-data-grid-pro/esm/components/GridDetailPanelToggleCell.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var useUtilityClasses3 = (ownerState) => {
  const {
    classes,
    isExpanded
  } = ownerState;
  const slots = {
    root: ["detailPanelToggleCell", isExpanded && "detailPanelToggleCell--expanded"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function GridDetailPanelToggleCell(props) {
  var _a;
  const {
    id,
    value: isExpanded
  } = props;
  const rootProps = useGridRootProps2();
  const apiRef = useGridApiContext2();
  const ownerState = {
    classes: rootProps.classes,
    isExpanded
  };
  const classes = useUtilityClasses3(ownerState);
  const contentCache = useGridSelector(apiRef, gridDetailPanelExpandedRowsContentCacheSelector);
  const hasContent = React11.isValidElement(contentCache[id]);
  const Icon = isExpanded ? rootProps.slots.detailPanelCollapseIcon : rootProps.slots.detailPanelExpandIcon;
  return (0, import_jsx_runtime6.jsx)(rootProps.slots.baseIconButton, _extends({
    size: "small",
    tabIndex: -1,
    disabled: !hasContent,
    className: classes.root,
    "aria-label": isExpanded ? apiRef.current.getLocaleText("collapseDetailPanel") : apiRef.current.getLocaleText("expandDetailPanel")
  }, (_a = rootProps.slotProps) == null ? void 0 : _a.baseIconButton, {
    children: (0, import_jsx_runtime6.jsx)(Icon, {
      fontSize: "inherit"
    })
  }));
}
true ? GridDetailPanelToggleCell.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * GridApi that let you manipulate the grid.
   */
  api: import_prop_types3.default.object.isRequired,
  /**
   * The mode of the cell.
   */
  cellMode: import_prop_types3.default.oneOf(["edit", "view"]).isRequired,
  /**
   * The column of the row that the current cell belongs to.
   */
  colDef: import_prop_types3.default.object.isRequired,
  /**
   * The column field of the cell that triggered the event.
   */
  field: import_prop_types3.default.string.isRequired,
  /**
   * A ref allowing to set imperative focus.
   * It can be passed to the element that should receive focus.
   * @ignore - do not document.
   */
  focusElementRef: import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.shape({
    current: import_prop_types3.default.shape({
      focus: import_prop_types3.default.func.isRequired
    })
  })]),
  /**
   * The cell value formatted with the column valueFormatter.
   */
  formattedValue: import_prop_types3.default.any,
  /**
   * If true, the cell is the active element.
   */
  hasFocus: import_prop_types3.default.bool.isRequired,
  /**
   * The grid row id.
   */
  id: import_prop_types3.default.oneOfType([import_prop_types3.default.number, import_prop_types3.default.string]).isRequired,
  /**
   * If true, the cell is editable.
   */
  isEditable: import_prop_types3.default.bool,
  /**
   * The row model of the row that the current cell belongs to.
   */
  row: import_prop_types3.default.any.isRequired,
  /**
   * The node of the row that the current cell belongs to.
   */
  rowNode: import_prop_types3.default.object.isRequired,
  /**
   * the tabIndex value.
   */
  tabIndex: import_prop_types3.default.oneOf([-1, 0]).isRequired,
  /**
   * The cell value.
   * If the column has `valueGetter`, use `params.row` to directly access the fields.
   */
  value: import_prop_types3.default.any
} : void 0;

// node_modules/@mui/x-data-grid-pro/esm/material/icons.js
var React12 = __toESM(require_react());
init_utils2();
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var GridPushPinRightIcon = createSvgIcon((0, import_jsx_runtime7.jsx)("g", {
  transform: "rotate(-30 15 10)",
  children: (0, import_jsx_runtime7.jsx)("path", {
    d: "M16,9V4l1,0c0.55,0,1-0.45,1-1v0c0-0.55-0.45-1-1-1H7C6.45,2,6,2.45,6,3v0 c0,0.55,0.45,1,1,1l1,0v5c0,1.66-1.34,3-3,3h0v2h5.97v7l1,1l1-1v-7H19v-2h0C17.34,12,16,10.66,16,9z",
    fillRule: "evenodd"
  })
}), "PushPinRight");
var GridPushPinLeftIcon = createSvgIcon((0, import_jsx_runtime7.jsx)("g", {
  transform: "rotate(30 8 12)",
  children: (0, import_jsx_runtime7.jsx)("path", {
    d: "M16,9V4l1,0c0.55,0,1-0.45,1-1v0c0-0.55-0.45-1-1-1H7C6.45,2,6,2.45,6,3v0 c0,0.55,0.45,1,1,1l1,0v5c0,1.66-1.34,3-3,3h0v2h5.97v7l1,1l1-1v-7H19v-2h0C17.34,12,16,10.66,16,9z",
    fillRule: "evenodd"
  })
}), "PushPinLeft");

// node_modules/@mui/x-data-grid-pro/esm/components/headerFiltering/GridHeaderFilterMenuContainer.js
init_extends();
init_objectWithoutPropertiesLoose();
var React13 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());
init_utils();
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var _excluded = ["operators", "item", "field", "buttonRef", "headerFilterMenuRef", "disabled"];
var sx = {
  width: 22,
  height: 22,
  margin: "auto 0 10px 5px"
};
function GridHeaderFilterMenuContainer(props) {
  var _a;
  const {
    operators,
    item,
    field,
    buttonRef,
    headerFilterMenuRef,
    disabled = false
  } = props, others = _objectWithoutPropertiesLoose(props, _excluded);
  const buttonId = useId();
  const menuId = useId();
  const rootProps = useGridRootProps2();
  const apiRef = useGridApiContext();
  const menuOpenField = useGridSelector(apiRef, gridHeaderFilteringMenuSelector);
  const open = Boolean(menuOpenField === field && headerFilterMenuRef.current);
  const handleClick = (event) => {
    headerFilterMenuRef.current = event.currentTarget;
    apiRef.current.showHeaderFilterMenu(field);
  };
  if (!rootProps.slots.headerFilterMenu) {
    return null;
  }
  const label = apiRef.current.getLocaleText("filterPanelOperator");
  const labelString = label ? String(label) : void 0;
  return (0, import_jsx_runtime8.jsxs)(React13.Fragment, {
    children: [(0, import_jsx_runtime8.jsx)(rootProps.slots.baseIconButton, _extends({
      id: buttonId,
      ref: buttonRef,
      "aria-label": labelString,
      title: labelString,
      "aria-controls": menuId,
      "aria-expanded": open ? "true" : void 0,
      "aria-haspopup": "true",
      tabIndex: -1,
      size: "small",
      onClick: handleClick,
      sx,
      disabled
    }, (_a = rootProps.slotProps) == null ? void 0 : _a.baseIconButton, {
      children: (0, import_jsx_runtime8.jsx)(rootProps.slots.openFilterButtonIcon, {
        fontSize: "small"
      })
    })), (0, import_jsx_runtime8.jsx)(rootProps.slots.headerFilterMenu, _extends({
      field,
      open,
      item,
      target: headerFilterMenuRef.current,
      operators,
      labelledBy: buttonId,
      id: menuId
    }, others))]
  });
}
true ? GridHeaderFilterMenuContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  applyFilterChanges: import_prop_types4.default.func.isRequired,
  buttonRef: refType_default,
  disabled: import_prop_types4.default.bool,
  field: import_prop_types4.default.string.isRequired,
  headerFilterMenuRef: import_prop_types4.default.shape({
    current: import_prop_types4.default.object
  }).isRequired,
  item: import_prop_types4.default.shape({
    field: import_prop_types4.default.string.isRequired,
    id: import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string]),
    operator: import_prop_types4.default.string.isRequired,
    value: import_prop_types4.default.any
  }).isRequired,
  operators: import_prop_types4.default.arrayOf(import_prop_types4.default.shape({
    getApplyFilterFn: import_prop_types4.default.func.isRequired,
    getValueAsString: import_prop_types4.default.func,
    headerLabel: import_prop_types4.default.string,
    InputComponent: import_prop_types4.default.elementType,
    InputComponentProps: import_prop_types4.default.object,
    label: import_prop_types4.default.string,
    requiresFilterValue: import_prop_types4.default.bool,
    value: import_prop_types4.default.string.isRequired
  })).isRequired
} : void 0;

// node_modules/@mui/x-data-grid-pro/esm/components/headerFiltering/GridHeaderFilterCell.js
init_extends();
init_objectWithoutPropertiesLoose();
var React15 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());
init_clsx();
init_utils();

// node_modules/@mui/x-data-grid-pro/esm/components/headerFiltering/GridHeaderFilterClearButton.js
init_extends();
var React14 = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var sx2 = {
  padding: "2px"
};
function GridHeaderFilterClearButton(props) {
  var _a;
  const rootProps = useGridRootProps2();
  return (0, import_jsx_runtime9.jsx)(rootProps.slots.baseIconButton, _extends({
    tabIndex: -1,
    "aria-label": "Clear filter",
    size: "small",
    sx: sx2
  }, props, (_a = rootProps.slotProps) == null ? void 0 : _a.baseIconButton, {
    children: (0, import_jsx_runtime9.jsx)(rootProps.slots.columnMenuClearIcon, {
      fontSize: "inherit"
    })
  }));
}

// node_modules/@mui/x-data-grid-pro/esm/components/headerFiltering/GridHeaderFilterCell.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var _excluded2 = ["colIndex", "height", "hasFocus", "width", "headerClassName", "colDef", "item", "headerFilterMenuRef", "InputComponentProps", "showClearIcon", "pinnedPosition", "style", "indexInSection", "sectionLength", "gridHasFiller"];
var useUtilityClasses4 = (ownerState) => {
  const {
    colDef,
    classes,
    showRightBorder,
    showLeftBorder,
    pinnedPosition
  } = ownerState;
  const slots = {
    root: ["columnHeader", colDef.headerAlign === "left" && "columnHeader--alignLeft", colDef.headerAlign === "center" && "columnHeader--alignCenter", colDef.headerAlign === "right" && "columnHeader--alignRight", "withBorderColor", showRightBorder && "columnHeader--withRightBorder", showLeftBorder && "columnHeader--withLeftBorder", pinnedPosition === "left" && "columnHeader--pinnedLeft", pinnedPosition === "right" && "columnHeader--pinnedRight"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
var dateSx = {
  [`& input[value=""]:not(:focus)`]: {
    color: "transparent"
  }
};
var GridHeaderFilterCell = React15.forwardRef((props, ref) => {
  const {
    colIndex,
    height,
    hasFocus,
    width,
    headerClassName,
    colDef,
    item,
    headerFilterMenuRef,
    InputComponentProps,
    showClearIcon = true,
    pinnedPosition,
    style: styleProp,
    indexInSection,
    sectionLength,
    gridHasFiller
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  const apiRef = useGridPrivateApiContext();
  const columnFields = useGridSelector(apiRef, gridVisibleColumnFieldsSelector);
  const rootProps = useGridRootProps2();
  const cellRef = React15.useRef(null);
  const handleRef = useForkRef(ref, cellRef);
  const inputRef = React15.useRef(null);
  const buttonRef = React15.useRef(null);
  const editingField = useGridSelector(apiRef, gridHeaderFilteringEditFieldSelector);
  const isEditing = editingField === colDef.field;
  const menuOpenField = useGridSelector(apiRef, gridHeaderFilteringMenuSelector);
  const isMenuOpen = menuOpenField === colDef.field;
  const filterOperators = React15.useMemo(() => {
    if (!colDef.filterOperators) {
      return [];
    }
    return colDef.filterOperators.filter((operator) => operator.value !== "isAnyOf");
  }, [colDef.filterOperators]);
  const filterModel = useGridSelector(apiRef, gridFilterModelSelector);
  const filterableColumnsLookup = useGridSelector(apiRef, gridFilterableColumnLookupSelector);
  const isFilterReadOnly = React15.useMemo(() => {
    if (!(filterModel == null ? void 0 : filterModel.items.length)) {
      return false;
    }
    const filterModelItem = filterModel.items.find((it) => it.field === colDef.field);
    return filterModelItem ? !filterableColumnsLookup[filterModelItem.field] : false;
  }, [colDef.field, filterModel, filterableColumnsLookup]);
  const currentOperator = React15.useMemo(() => filterOperators.find((operator) => operator.value === item.operator) ?? filterOperators[0], [item.operator, filterOperators]);
  const InputComponent = colDef.filterable || isFilterReadOnly ? currentOperator.InputComponent : null;
  const applyFilterChanges = React15.useCallback((updatedItem) => {
    if (item.value && !updatedItem.value) {
      apiRef.current.deleteFilterItem(updatedItem);
      return;
    }
    apiRef.current.upsertFilterItem(updatedItem);
  }, [apiRef, item]);
  const clearFilterItem = React15.useCallback(() => {
    apiRef.current.deleteFilterItem(item);
  }, [apiRef, item]);
  let headerFilterComponent;
  if (colDef.renderHeaderFilter) {
    headerFilterComponent = colDef.renderHeaderFilter(_extends({}, props, {
      inputRef
    }));
  }
  React15.useLayoutEffect(() => {
    if (hasFocus && !isMenuOpen) {
      let focusableElement = cellRef.current.querySelector('[tabindex="0"]');
      if (isEditing && InputComponent) {
        focusableElement = inputRef.current;
      }
      const elementToFocus = focusableElement || cellRef.current;
      elementToFocus == null ? void 0 : elementToFocus.focus();
      apiRef.current.columnHeadersContainerRef.current.scrollLeft = 0;
    }
  }, [InputComponent, apiRef, hasFocus, isEditing, isMenuOpen]);
  const onKeyDown = React15.useCallback((event) => {
    if (isMenuOpen || isNavigationKey(event.key) || isFilterReadOnly) {
      return;
    }
    switch (event.key) {
      case "Escape":
        if (isEditing) {
          apiRef.current.stopHeaderFilterEditMode();
        }
        break;
      case "Enter":
        if (isEditing) {
          if (!event.defaultPrevented) {
            apiRef.current.stopHeaderFilterEditMode();
            break;
          }
        }
        if (event.metaKey || event.ctrlKey) {
          headerFilterMenuRef.current = buttonRef.current;
          apiRef.current.showHeaderFilterMenu(colDef.field);
          break;
        }
        apiRef.current.startHeaderFilterEditMode(colDef.field);
        break;
      case "Tab": {
        if (isEditing) {
          const fieldToFocus = columnFields[colIndex + (event.shiftKey ? -1 : 1)] ?? null;
          if (fieldToFocus) {
            apiRef.current.startHeaderFilterEditMode(fieldToFocus);
            apiRef.current.setColumnHeaderFilterFocus(fieldToFocus, event);
          }
        }
        break;
      }
      default:
        if (isEditing || event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) {
          break;
        }
        apiRef.current.startHeaderFilterEditMode(colDef.field);
        break;
    }
  }, [apiRef, colDef.field, colIndex, columnFields, headerFilterMenuRef, isEditing, isFilterReadOnly, isMenuOpen]);
  const publish = React15.useCallback((eventName, propHandler) => (event) => {
    apiRef.current.publishEvent(eventName, apiRef.current.getColumnHeaderParams(colDef.field), event);
    if (propHandler) {
      propHandler(event);
    }
  }, [apiRef, colDef.field]);
  const onMouseDown = React15.useCallback((event) => {
    var _a, _b;
    if (!hasFocus) {
      if ((_b = (_a = inputRef.current) == null ? void 0 : _a.contains) == null ? void 0 : _b.call(_a, event.target)) {
        inputRef.current.focus();
      }
      apiRef.current.setColumnHeaderFilterFocus(colDef.field, event);
    }
  }, [apiRef, colDef.field, hasFocus]);
  const mouseEventsHandlers = React15.useMemo(() => ({
    onKeyDown: publish("headerFilterKeyDown", onKeyDown),
    onClick: publish("headerFilterClick"),
    onMouseDown: publish("headerFilterMouseDown", onMouseDown),
    onBlur: publish("headerFilterBlur")
  }), [onMouseDown, onKeyDown, publish]);
  const showLeftBorder = shouldCellShowLeftBorder(pinnedPosition, indexInSection);
  const showRightBorder = shouldCellShowRightBorder(pinnedPosition, indexInSection, sectionLength, rootProps.showCellVerticalBorder, gridHasFiller);
  const ownerState = _extends({}, rootProps, {
    pinnedPosition,
    colDef,
    showLeftBorder,
    showRightBorder
  });
  const classes = useUtilityClasses4(ownerState);
  const isNoInputOperator = currentOperator.requiresFilterValue === false;
  const isApplied = Boolean(item == null ? void 0 : item.value) || isNoInputOperator;
  const label = currentOperator.headerLabel ?? apiRef.current.getLocaleText(`headerFilterOperator${capitalize(item.operator)}`);
  const isFilterActive = isApplied || hasFocus;
  return (0, import_jsx_runtime10.jsxs)("div", _extends({
    className: clsx_default(classes.root, headerClassName),
    ref: handleRef,
    style: _extends({
      height,
      width,
      minWidth: width,
      maxWidth: width
    }, styleProp),
    role: "columnheader",
    "aria-colindex": colIndex + 1,
    "aria-label": headerFilterComponent == null ? colDef.headerName ?? colDef.field : void 0
  }, other, mouseEventsHandlers, {
    children: [headerFilterComponent, InputComponent && headerFilterComponent === void 0 ? (0, import_jsx_runtime10.jsxs)(React15.Fragment, {
      children: [(0, import_jsx_runtime10.jsx)(InputComponent, _extends({
        apiRef,
        item,
        inputRef,
        applyValue: applyFilterChanges,
        onFocus: () => apiRef.current.startHeaderFilterEditMode(colDef.field),
        onBlur: (event) => {
          var _a;
          apiRef.current.stopHeaderFilterEditMode();
          if (!((_a = event.relatedTarget) == null ? void 0 : _a.className.includes("columnHeader"))) {
            apiRef.current.setState((state) => _extends({}, state, {
              focus: {
                cell: null,
                columnHeader: null,
                columnHeaderFilter: null,
                columnGroupHeader: null
              }
            }));
          }
        },
        label: capitalize(label),
        placeholder: "",
        isFilterActive,
        clearButton: showClearIcon && isApplied ? (0, import_jsx_runtime10.jsx)(GridHeaderFilterClearButton, {
          onClick: clearFilterItem,
          disabled: isFilterReadOnly
        }) : null,
        disabled: isFilterReadOnly || isNoInputOperator,
        tabIndex: -1,
        InputLabelProps: null,
        sx: colDef.type === "date" || colDef.type === "dateTime" ? dateSx : void 0
      }, isNoInputOperator ? {
        value: ""
      } : {}, currentOperator == null ? void 0 : currentOperator.InputComponentProps, InputComponentProps)), (0, import_jsx_runtime10.jsx)(GridHeaderFilterMenuContainer, {
        operators: filterOperators,
        item,
        field: colDef.field,
        disabled: isFilterReadOnly,
        applyFilterChanges,
        headerFilterMenuRef,
        buttonRef
      })]
    }) : null]
  }));
});
true ? GridHeaderFilterCell.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  colDef: import_prop_types5.default.object.isRequired,
  colIndex: import_prop_types5.default.number.isRequired,
  gridHasFiller: import_prop_types5.default.bool.isRequired,
  hasFocus: import_prop_types5.default.bool,
  /**
   * Class name that will be added in the column header cell.
   */
  headerClassName: import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.string]),
  headerFilterMenuRef: import_prop_types5.default.shape({
    current: import_prop_types5.default.object
  }).isRequired,
  height: import_prop_types5.default.number.isRequired,
  indexInSection: import_prop_types5.default.number.isRequired,
  InputComponentProps: import_prop_types5.default.object,
  item: import_prop_types5.default.shape({
    field: import_prop_types5.default.string.isRequired,
    id: import_prop_types5.default.oneOfType([import_prop_types5.default.number, import_prop_types5.default.string]),
    operator: import_prop_types5.default.string.isRequired,
    value: import_prop_types5.default.any
  }).isRequired,
  pinnedPosition: import_prop_types5.default.oneOf(["left", "right"]),
  sectionLength: import_prop_types5.default.number.isRequired,
  showClearIcon: import_prop_types5.default.bool,
  sortIndex: import_prop_types5.default.number,
  style: import_prop_types5.default.object,
  tabIndex: import_prop_types5.default.oneOf([-1, 0]).isRequired,
  width: import_prop_types5.default.number.isRequired
} : void 0;
var Memoized = fastMemo(GridHeaderFilterCell);

// node_modules/@mui/x-data-grid-pro/esm/components/headerFiltering/GridHeaderFilterMenu.js
init_extends();
var React16 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
init_utils();
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
function GridHeaderFilterMenu({
  open,
  field,
  target,
  applyFilterChanges,
  operators,
  item,
  id,
  labelledBy
}) {
  const apiRef = useGridApiContext();
  const hideMenu = React16.useCallback(() => {
    apiRef.current.hideHeaderFilterMenu();
  }, [apiRef]);
  const handleListKeyDown = React16.useCallback((event) => {
    if (event.key === "Tab") {
      event.preventDefault();
    }
    if (event.key === "Escape" || event.key === "Tab") {
      hideMenu();
    }
  }, [hideMenu]);
  if (!target) {
    return null;
  }
  return (0, import_jsx_runtime11.jsx)(GridMenu, {
    placement: "bottom-end",
    open,
    target,
    onClose: hideMenu,
    children: (0, import_jsx_runtime11.jsx)(MenuList_default, {
      "aria-labelledby": labelledBy,
      id,
      onKeyDown: handleListKeyDown,
      children: operators.map((op, i2) => {
        const label = (op == null ? void 0 : op.headerLabel) ?? apiRef.current.getLocaleText(`headerFilterOperator${capitalize(op.value)}`);
        return (0, import_jsx_runtime11.jsx)(MenuItem_default, {
          onClick: () => {
            applyFilterChanges(_extends({}, item, {
              operator: op.value
            }));
            hideMenu();
          },
          autoFocus: i2 === 0 ? open : false,
          selected: op.value === item.operator,
          children: label
        }, `${field}-${op.value}`);
      })
    })
  });
}
true ? GridHeaderFilterMenu.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  applyFilterChanges: import_prop_types6.default.func.isRequired,
  field: import_prop_types6.default.string.isRequired,
  id: import_prop_types6.default.string.isRequired,
  item: import_prop_types6.default.shape({
    field: import_prop_types6.default.string.isRequired,
    id: import_prop_types6.default.oneOfType([import_prop_types6.default.number, import_prop_types6.default.string]),
    operator: import_prop_types6.default.string.isRequired,
    value: import_prop_types6.default.any
  }).isRequired,
  labelledBy: import_prop_types6.default.string.isRequired,
  open: import_prop_types6.default.bool.isRequired,
  operators: import_prop_types6.default.arrayOf(import_prop_types6.default.shape({
    getApplyFilterFn: import_prop_types6.default.func.isRequired,
    getValueAsString: import_prop_types6.default.func,
    headerLabel: import_prop_types6.default.string,
    InputComponent: import_prop_types6.default.elementType,
    InputComponentProps: import_prop_types6.default.object,
    label: import_prop_types6.default.string,
    requiresFilterValue: import_prop_types6.default.bool,
    value: import_prop_types6.default.string.isRequired
  })).isRequired,
  target: HTMLElementType
} : void 0;

// node_modules/@mui/x-data-grid-pro/esm/utils/tree/utils.js
init_extends();
var getGroupRowIdFromPath = (path) => {
  const pathStr = path.map((groupingCriteria) => `${groupingCriteria.field}/${groupingCriteria.key}`).join("-");
  return `auto-generated-row-${pathStr}`;
};
var getNodePathInTree = ({
  id,
  tree
}) => {
  const path = [];
  let node = tree[id];
  while (node.id !== GRID_ROOT_GROUP_ID) {
    path.push({
      field: node.type === "leaf" ? null : node.groupingField,
      key: node.groupingKey
    });
    node = tree[node.parent];
  }
  path.reverse();
  return path;
};
var updateGroupDefaultExpansion = (node, defaultGroupingExpansionDepth, isGroupExpandedByDefault) => {
  let childrenExpanded;
  if (node.id === GRID_ROOT_GROUP_ID) {
    childrenExpanded = true;
  } else if (isGroupExpandedByDefault) {
    childrenExpanded = isGroupExpandedByDefault(node);
  } else {
    childrenExpanded = defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > node.depth;
  }
  node.childrenExpanded = childrenExpanded;
  return node;
};
var insertNodeInTree = (node, tree, treeDepths, previousTree) => {
  var _a;
  tree[node.id] = node;
  treeDepths[node.depth] = (treeDepths[node.depth] ?? 0) + 1;
  const parentNode = tree[node.parent];
  if (node.type === "group" || node.type === "leaf") {
    const groupingFieldName = node.groupingField ?? "__no_field__";
    const groupingKeyName = node.groupingKey ?? "__no_key__";
    const groupingField = (_a = parentNode.childrenFromPath) == null ? void 0 : _a[groupingFieldName];
    if (previousTree !== null && previousTree[parentNode.id] === tree[parentNode.id]) {
      parentNode.children = [...parentNode.children, node.id];
    } else {
      parentNode.children.push(node.id);
    }
    if (groupingField == null) {
      parentNode.childrenFromPath[groupingFieldName] = {
        [groupingKeyName.toString()]: node.id
      };
    } else {
      groupingField[groupingKeyName.toString()] = node.id;
    }
  } else if (node.type === "footer") {
    parentNode.footerId = node.id;
  }
};
var removeNodeFromTree = ({
  node,
  tree,
  treeDepths
}) => {
  delete tree[node.id];
  const nodeDepth = node.depth;
  const currentNodeCount = treeDepths[nodeDepth];
  if (currentNodeCount === 1) {
    delete treeDepths[nodeDepth];
  } else {
    treeDepths[nodeDepth] = currentNodeCount - 1;
  }
  const parentNode = tree[node.parent];
  if (node.type === "footer") {
    tree[parentNode.id] = _extends({}, parentNode, {
      footerId: null
    });
  } else {
    const groupingField = node.groupingField ?? "__no_field__";
    const groupingKey = node.groupingKey ?? "__no_key__";
    const children = parentNode.children.filter((childId) => childId !== node.id);
    const childrenFromPath = parentNode.childrenFromPath;
    delete childrenFromPath[groupingField][groupingKey.toString()];
    tree[parentNode.id] = _extends({}, parentNode, {
      children,
      childrenFromPath
    });
  }
};
var updateGroupNodeIdAndAutoGenerated = ({
  node,
  updatedNode,
  previousTree,
  tree,
  treeDepths
}) => {
  node.children.forEach((childId) => {
    tree[childId] = _extends({}, tree[childId], {
      parent: updatedNode.id
    });
  });
  removeNodeFromTree({
    node,
    tree,
    treeDepths
  });
  const groupNode = _extends({}, node, updatedNode);
  insertNodeInTree(groupNode, tree, treeDepths, previousTree);
};
var createUpdatedGroupsManager = () => ({
  value: {},
  addAction(groupId, action) {
    if (!this.value[groupId]) {
      this.value[groupId] = {};
    }
    this.value[groupId][action] = true;
  }
});
var getVisibleRowsLookup = ({
  tree,
  filteredRowsLookup
}) => {
  if (!filteredRowsLookup) {
    return {};
  }
  const visibleRowsLookup = {};
  const handleTreeNode = (node, areAncestorsExpanded) => {
    const isPassingFiltering = filteredRowsLookup[node.id];
    if (node.type === "group") {
      node.children.forEach((childId) => {
        const childNode = tree[childId];
        handleTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded);
      });
    }
    visibleRowsLookup[node.id] = isPassingFiltering && areAncestorsExpanded;
    if (node.type === "group" && node.footerId != null) {
      visibleRowsLookup[node.footerId] = isPassingFiltering && areAncestorsExpanded && !!node.childrenExpanded;
    }
  };
  const nodes = Object.values(tree);
  for (let i2 = 0; i2 < nodes.length; i2 += 1) {
    const node = nodes[i2];
    if (node.depth === 0) {
      handleTreeNode(node, true);
    }
  }
  return visibleRowsLookup;
};

// node_modules/@mui/x-data-grid-pro/esm/utils/tree/insertDataRowInTree.js
var insertDataRowInTree = ({
  id,
  path,
  updatedGroupsManager,
  previousTree,
  tree,
  treeDepths,
  onDuplicatePath,
  isGroupExpandedByDefault,
  defaultGroupingExpansionDepth
}) => {
  var _a, _b;
  let parentNodeId = GRID_ROOT_GROUP_ID;
  for (let depth = 0; depth < path.length; depth += 1) {
    const {
      key,
      field
    } = path[depth];
    const fieldWithDefaultValue = field ?? "__no_field__";
    const keyWithDefaultValue = key ?? "__no_key__";
    const existingNodeIdWithPartialPath = (_b = (_a = tree[parentNodeId].childrenFromPath) == null ? void 0 : _a[fieldWithDefaultValue]) == null ? void 0 : _b[keyWithDefaultValue.toString()];
    if (depth === path.length - 1) {
      if (existingNodeIdWithPartialPath == null) {
        const leafNode = {
          type: "leaf",
          id,
          depth,
          parent: parentNodeId,
          groupingKey: key
        };
        updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, "insertChildren");
        insertNodeInTree(leafNode, tree, treeDepths, previousTree);
      } else {
        const existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath];
        if (existingNodeWithPartialPath.type === "group" && existingNodeWithPartialPath.isAutoGenerated) {
          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, "removeChildren");
          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, "insertChildren");
          updateGroupNodeIdAndAutoGenerated({
            tree,
            previousTree,
            treeDepths,
            node: existingNodeWithPartialPath,
            updatedNode: {
              id,
              isAutoGenerated: false
            }
          });
        } else {
          onDuplicatePath == null ? void 0 : onDuplicatePath(existingNodeIdWithPartialPath, id, path);
        }
      }
    } else if (existingNodeIdWithPartialPath == null) {
      const nodeId = getGroupRowIdFromPath(path.slice(0, depth + 1));
      const autoGeneratedGroupNode = {
        type: "group",
        id: nodeId,
        parent: parentNodeId,
        depth,
        isAutoGenerated: true,
        groupingKey: key,
        groupingField: field,
        children: [],
        childrenFromPath: {},
        childrenExpanded: false
      };
      updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, "insertChildren");
      insertNodeInTree(updateGroupDefaultExpansion(autoGeneratedGroupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault), tree, treeDepths, previousTree);
      parentNodeId = nodeId;
    } else {
      const currentGroupNode = tree[existingNodeIdWithPartialPath];
      if (currentGroupNode.type !== "group") {
        const groupNode = {
          type: "group",
          id: currentGroupNode.id,
          parent: currentGroupNode.parent,
          depth: currentGroupNode.depth,
          isAutoGenerated: false,
          groupingKey: key,
          groupingField: field,
          children: [],
          childrenFromPath: {},
          childrenExpanded: false
        };
        tree[existingNodeIdWithPartialPath] = updateGroupDefaultExpansion(groupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault);
      }
      parentNodeId = currentGroupNode.id;
    }
  }
};

// node_modules/@mui/x-data-grid-pro/esm/utils/tree/createRowTree.js
var createRowTree = (params) => {
  const dataRowIds = [];
  const tree = {
    [GRID_ROOT_GROUP_ID]: buildRootGroup()
  };
  const treeDepths = {};
  for (let i2 = 0; i2 < params.nodes.length; i2 += 1) {
    const node = params.nodes[i2];
    dataRowIds.push(node.id);
    insertDataRowInTree({
      tree,
      previousTree: params.previousTree,
      id: node.id,
      path: node.path,
      onDuplicatePath: params.onDuplicatePath,
      treeDepths,
      isGroupExpandedByDefault: params.isGroupExpandedByDefault,
      defaultGroupingExpansionDepth: params.defaultGroupingExpansionDepth
    });
  }
  return {
    tree,
    treeDepths,
    groupingName: params.groupingName,
    dataRowIds
  };
};

// node_modules/@mui/x-data-grid-pro/esm/utils/tree/sortRowTree.js
var Node = class {
  constructor(data, next) {
    this.next = void 0;
    this.data = void 0;
    this.next = next;
    this.data = data;
  }
  insertAfter(list) {
    if (!list.first || !list.last) {
      return;
    }
    const next = this.next;
    this.next = list.first;
    list.last.next = next;
  }
};
var List = class _List {
  constructor(first, last) {
    this.first = void 0;
    this.last = void 0;
    this.first = first;
    this.last = last;
  }
  data() {
    const array = [];
    this.forEach((node) => {
      array.push(node.data);
    });
    return array;
  }
  forEach(fn) {
    let current = this.first;
    while (current !== null) {
      fn(current);
      current = current.next;
    }
  }
  static from(array) {
    if (array.length === 0) {
      return new _List(null, null);
    }
    let index = 0;
    const first = new Node(array[index], null);
    let current = first;
    while (index + 1 < array.length) {
      index += 1;
      const node = new Node(array[index], null);
      current.next = node;
      current = node;
    }
    return new _List(first, current);
  }
};
var sortRowTree = (params) => {
  const {
    rowTree,
    disableChildrenSorting,
    sortRowList,
    shouldRenderGroupBelowLeaves
  } = params;
  const sortedGroupedByParentRows = /* @__PURE__ */ new Map();
  const sortGroup = (node) => {
    const shouldSortGroup = !!sortRowList && (!disableChildrenSorting || node.depth === -1);
    let sortedRowIds;
    if (shouldSortGroup) {
      for (let i2 = 0; i2 < node.children.length; i2 += 1) {
        const childNode = rowTree[node.children[i2]];
        if (childNode.type === "group") {
          sortGroup(childNode);
        }
      }
      sortedRowIds = sortRowList(node.children.map((childId) => rowTree[childId]));
    } else if (shouldRenderGroupBelowLeaves) {
      const childrenLeaves = [];
      const childrenGroups = [];
      for (let i2 = 0; i2 < node.children.length; i2 += 1) {
        const childId = node.children[i2];
        const childNode = rowTree[childId];
        if (childNode.type === "group") {
          sortGroup(childNode);
          childrenGroups.push(childId);
        } else if (childNode.type === "leaf") {
          childrenLeaves.push(childId);
        }
      }
      sortedRowIds = [...childrenLeaves, ...childrenGroups];
    } else {
      for (let i2 = 0; i2 < node.children.length; i2 += 1) {
        const childNode = rowTree[node.children[i2]];
        if (childNode.type === "group") {
          sortGroup(childNode);
        }
      }
      sortedRowIds = [...node.children];
    }
    if (node.footerId != null) {
      sortedRowIds.push(node.footerId);
    }
    sortedGroupedByParentRows.set(node.id, sortedRowIds);
  };
  sortGroup(rowTree[GRID_ROOT_GROUP_ID]);
  const rootList = List.from(sortedGroupedByParentRows.get(GRID_ROOT_GROUP_ID));
  rootList.forEach((node) => {
    const children = sortedGroupedByParentRows.get(node.data);
    if (children == null ? void 0 : children.length) {
      node.insertAfter(List.from(children));
    }
  });
  return rootList.data();
};

// node_modules/@mui/x-data-grid-pro/esm/utils/tree/updateRowTree.js
init_extends();

// node_modules/@mui/x-data-grid-pro/esm/utils/tree/removeDataRowFromTree.js
var removeNodeAndCleanParent = ({
  node,
  tree,
  treeDepths,
  updatedGroupsManager
}) => {
  removeNodeFromTree({
    node,
    tree,
    treeDepths
  });
  if (node.type === "group" && node.footerId != null) {
    removeNodeFromTree({
      node: tree[node.footerId],
      tree,
      treeDepths
    });
  }
  const parentNode = tree[node.parent];
  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNode.id, "removeChildren");
  const shouldDeleteGroup = parentNode.id !== GRID_ROOT_GROUP_ID && parentNode.children.length === 0;
  if (shouldDeleteGroup) {
    if (parentNode.isAutoGenerated) {
      removeNodeAndCleanParent({
        node: parentNode,
        tree,
        treeDepths
      });
    } else {
      tree[parentNode.id] = {
        type: "leaf",
        id: parentNode.id,
        depth: parentNode.depth,
        parent: parentNode.parent,
        groupingKey: parentNode.groupingKey
      };
    }
  }
};
var replaceDataGroupWithAutoGeneratedGroup = ({
  node,
  tree,
  treeDepths,
  updatedGroupsManager
}) => {
  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(node.parent, "removeChildren");
  updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(node.parent, "insertChildren");
  updateGroupNodeIdAndAutoGenerated({
    previousTree: null,
    tree,
    treeDepths,
    node,
    updatedNode: {
      id: getGroupRowIdFromPath(getNodePathInTree({
        id: node.id,
        tree
      })),
      isAutoGenerated: true
    }
  });
};
var removeDataRowFromTree = ({
  id,
  tree,
  treeDepths,
  updatedGroupsManager
}) => {
  const node = tree[id];
  if (node.type === "group" && node.children.length > 0) {
    replaceDataGroupWithAutoGeneratedGroup({
      node,
      tree,
      treeDepths,
      updatedGroupsManager
    });
  } else {
    removeNodeAndCleanParent({
      node,
      tree,
      treeDepths,
      updatedGroupsManager
    });
  }
};

// node_modules/@mui/x-data-grid-pro/esm/utils/tree/updateRowTree.js
var updateRowTree = (params) => {
  const tree = _extends({}, params.previousTree);
  const treeDepths = _extends({}, params.previousTreeDepth);
  const updatedGroupsManager = createUpdatedGroupsManager();
  for (let i2 = 0; i2 < params.nodes.inserted.length; i2 += 1) {
    const {
      id,
      path
    } = params.nodes.inserted[i2];
    insertDataRowInTree({
      previousTree: params.previousTree,
      tree,
      treeDepths,
      updatedGroupsManager,
      id,
      path,
      onDuplicatePath: params.onDuplicatePath,
      isGroupExpandedByDefault: params.isGroupExpandedByDefault,
      defaultGroupingExpansionDepth: params.defaultGroupingExpansionDepth
    });
  }
  for (let i2 = 0; i2 < params.nodes.removed.length; i2 += 1) {
    const nodeId = params.nodes.removed[i2];
    removeDataRowFromTree({
      tree,
      treeDepths,
      updatedGroupsManager,
      id: nodeId
    });
  }
  for (let i2 = 0; i2 < params.nodes.modified.length; i2 += 1) {
    const {
      id,
      path
    } = params.nodes.modified[i2];
    const pathInPreviousTree = getNodePathInTree({
      tree,
      id
    });
    const isInSameGroup = isDeepEqual(pathInPreviousTree, path);
    if (!isInSameGroup) {
      removeDataRowFromTree({
        tree,
        treeDepths,
        updatedGroupsManager,
        id
      });
      insertDataRowInTree({
        previousTree: params.previousTree,
        tree,
        treeDepths,
        updatedGroupsManager,
        id,
        path,
        onDuplicatePath: params.onDuplicatePath,
        isGroupExpandedByDefault: params.isGroupExpandedByDefault,
        defaultGroupingExpansionDepth: params.defaultGroupingExpansionDepth
      });
    } else {
      updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(tree[id].parent, "modifyChildren");
    }
  }
  const dataRowIds = getTreeNodeDescendants(tree, GRID_ROOT_GROUP_ID, true);
  return {
    tree,
    treeDepths,
    groupingName: params.groupingName,
    dataRowIds,
    updatedGroupsManager
  };
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/treeData/useGridTreeDataPreProcessors.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var _excluded3 = ["hideDescendantCount"];
var useGridTreeDataPreProcessors = (privateApiRef, props) => {
  const setStrategyAvailability = React17.useCallback(() => {
    privateApiRef.current.setStrategyAvailability("rowTree", TREE_DATA_STRATEGY, props.treeData ? () => true : () => false);
  }, [privateApiRef, props.treeData]);
  const getGroupingColDef = React17.useCallback(() => {
    const groupingColDefProp = props.groupingColDef;
    let colDefOverride;
    if (typeof groupingColDefProp === "function") {
      const params = {
        groupingName: TREE_DATA_STRATEGY,
        fields: []
      };
      colDefOverride = groupingColDefProp(params);
    } else {
      colDefOverride = groupingColDefProp;
    }
    const _ref = colDefOverride ?? {}, {
      hideDescendantCount
    } = _ref, colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded3);
    const commonProperties = _extends({}, GRID_TREE_DATA_GROUPING_COL_DEF, {
      renderCell: (params) => (0, import_jsx_runtime12.jsx)(GridTreeDataGroupingCell, _extends({}, params, {
        hideDescendantCount
      })),
      headerName: privateApiRef.current.getLocaleText("treeDataGroupingHeaderName")
    });
    return _extends({}, commonProperties, colDefOverrideProperties, GRID_TREE_DATA_GROUPING_COL_DEF_FORCED_PROPERTIES);
  }, [privateApiRef, props.groupingColDef]);
  const updateGroupingColumn = React17.useCallback((columnsState) => {
    const groupingColDefField = GRID_TREE_DATA_GROUPING_COL_DEF_FORCED_PROPERTIES.field;
    const shouldHaveGroupingColumn = props.treeData;
    const prevGroupingColumn = columnsState.lookup[groupingColDefField];
    if (shouldHaveGroupingColumn) {
      const newGroupingColumn = getGroupingColDef();
      if (prevGroupingColumn) {
        newGroupingColumn.width = prevGroupingColumn.width;
        newGroupingColumn.flex = prevGroupingColumn.flex;
      }
      columnsState.lookup[groupingColDefField] = newGroupingColumn;
      if (prevGroupingColumn == null) {
        const index = columnsState.orderedFields[0] === GRID_CHECKBOX_SELECTION_FIELD ? 1 : 0;
        columnsState.orderedFields = [...columnsState.orderedFields.slice(0, index), groupingColDefField, ...columnsState.orderedFields.slice(index)];
      }
    } else if (!shouldHaveGroupingColumn && prevGroupingColumn) {
      delete columnsState.lookup[groupingColDefField];
      columnsState.orderedFields = columnsState.orderedFields.filter((field) => field !== groupingColDefField);
    }
    return columnsState;
  }, [props.treeData, getGroupingColDef]);
  const createRowTreeForTreeData = React17.useCallback((params) => {
    if (!props.getTreeDataPath) {
      throw new Error("MUI X: No getTreeDataPath given.");
    }
    const getRowTreeBuilderNode = (rowId) => ({
      id: rowId,
      path: props.getTreeDataPath(params.dataRowIdToModelLookup[rowId]).map((key) => ({
        key,
        field: null
      }))
    });
    const onDuplicatePath = (firstId, secondId, path) => {
      throw new Error(["MUI X: The path returned by `getTreeDataPath` should be unique.", `The rows with id #${firstId} and #${secondId} have the same.`, `Path: ${JSON.stringify(path.map((step) => step.key))}.`].join("\n"));
    };
    if (params.updates.type === "full") {
      return createRowTree({
        previousTree: params.previousTree,
        nodes: params.updates.rows.map(getRowTreeBuilderNode),
        defaultGroupingExpansionDepth: props.defaultGroupingExpansionDepth,
        isGroupExpandedByDefault: props.isGroupExpandedByDefault,
        groupingName: TREE_DATA_STRATEGY,
        onDuplicatePath
      });
    }
    return updateRowTree({
      nodes: {
        inserted: params.updates.actions.insert.map(getRowTreeBuilderNode),
        modified: params.updates.actions.modify.map(getRowTreeBuilderNode),
        removed: params.updates.actions.remove
      },
      previousTree: params.previousTree,
      previousTreeDepth: params.previousTreeDepths,
      defaultGroupingExpansionDepth: props.defaultGroupingExpansionDepth,
      isGroupExpandedByDefault: props.isGroupExpandedByDefault,
      groupingName: TREE_DATA_STRATEGY
    });
  }, [props.getTreeDataPath, props.defaultGroupingExpansionDepth, props.isGroupExpandedByDefault]);
  const filterRows = React17.useCallback((params) => {
    const rowTree = gridRowTreeSelector(privateApiRef);
    return filterRowTreeFromTreeData({
      rowTree,
      isRowMatchingFilters: params.isRowMatchingFilters,
      disableChildrenFiltering: props.disableChildrenFiltering,
      filterModel: params.filterModel,
      apiRef: privateApiRef
    });
  }, [privateApiRef, props.disableChildrenFiltering]);
  const sortRows = React17.useCallback((params) => {
    const rowTree = gridRowTreeSelector(privateApiRef);
    return sortRowTree({
      rowTree,
      sortRowList: params.sortRowList,
      disableChildrenSorting: props.disableChildrenSorting,
      shouldRenderGroupBelowLeaves: false
    });
  }, [privateApiRef, props.disableChildrenSorting]);
  useGridRegisterPipeProcessor(privateApiRef, "hydrateColumns", updateGroupingColumn);
  useGridRegisterStrategyProcessor(privateApiRef, TREE_DATA_STRATEGY, "rowTreeCreation", createRowTreeForTreeData);
  useGridRegisterStrategyProcessor(privateApiRef, TREE_DATA_STRATEGY, "filtering", filterRows);
  useGridRegisterStrategyProcessor(privateApiRef, TREE_DATA_STRATEGY, "sorting", sortRows);
  useGridRegisterStrategyProcessor(privateApiRef, TREE_DATA_STRATEGY, "visibleRowsLookupCreation", getVisibleRowsLookup);
  useFirstRender(() => {
    setStrategyAvailability();
  });
  const isFirstRender = React17.useRef(true);
  React17.useEffect(() => {
    if (!isFirstRender.current) {
      setStrategyAvailability();
    } else {
      isFirstRender.current = false;
    }
  }, [setStrategyAvailability]);
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/columnPinning/useGridColumnPinning.js
init_extends();
var React18 = __toESM(require_react());
var columnPinningStateInitializer = (state, props, apiRef) => {
  var _a;
  apiRef.current.caches.columnPinning = {
    orderedFieldsBeforePinningColumns: null
  };
  let model;
  if (props.pinnedColumns) {
    model = props.pinnedColumns;
  } else if ((_a = props.initialState) == null ? void 0 : _a.pinnedColumns) {
    model = props.initialState.pinnedColumns;
  } else {
    model = {};
  }
  return _extends({}, state, {
    pinnedColumns: model
  });
};
var useGridColumnPinning = (apiRef, props) => {
  var _a;
  const pinnedColumns = useGridSelector(apiRef, gridPinnedColumnsSelector);
  const calculateScrollLeft = React18.useCallback((initialValue, params) => {
    const visiblePinnedColumns = gridVisiblePinnedColumnDefinitionsSelector(apiRef);
    if (!params.colIndex || visiblePinnedColumns.left.length === 0 && visiblePinnedColumns.right.length === 0) {
      return initialValue;
    }
    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);
    const columnsTotalWidth = gridColumnsTotalWidthSelector(apiRef);
    const columnPositions = gridColumnPositionsSelector(apiRef);
    const clientWidth = apiRef.current.virtualScrollerRef.current.clientWidth;
    const scrollLeft = Math.abs(apiRef.current.virtualScrollerRef.current.scrollLeft);
    const offsetWidth = visibleColumns[params.colIndex].computedWidth;
    const offsetLeft = columnPositions[params.colIndex];
    const leftPinnedColumnsWidth = columnPositions[visiblePinnedColumns.left.length];
    const rightPinnedColumnsWidth = columnsTotalWidth - columnPositions[columnPositions.length - visiblePinnedColumns.right.length];
    const elementBottom = offsetLeft + offsetWidth;
    if (elementBottom - (clientWidth - rightPinnedColumnsWidth) > scrollLeft) {
      const left = elementBottom - (clientWidth - rightPinnedColumnsWidth);
      return _extends({}, initialValue, {
        left
      });
    }
    if (offsetLeft < scrollLeft + leftPinnedColumnsWidth) {
      const left = offsetLeft - leftPinnedColumnsWidth;
      return _extends({}, initialValue, {
        left
      });
    }
    return initialValue;
  }, [apiRef]);
  const addColumnMenuItems = React18.useCallback((columnMenuItems, colDef) => {
    if (props.disableColumnPinning) {
      return columnMenuItems;
    }
    if (colDef.pinnable === false) {
      return columnMenuItems;
    }
    return [...columnMenuItems, "columnMenuPinningItem"];
  }, [props.disableColumnPinning]);
  const checkIfCanBeReordered = React18.useCallback((initialValue, {
    targetIndex
  }) => {
    const visiblePinnedColumns = gridVisiblePinnedColumnDefinitionsSelector(apiRef);
    if (visiblePinnedColumns.left.length === 0 && visiblePinnedColumns.right.length === 0) {
      return initialValue;
    }
    if (visiblePinnedColumns.left.length > 0 && targetIndex < visiblePinnedColumns.left.length) {
      return false;
    }
    if (visiblePinnedColumns.right.length > 0) {
      const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);
      const firstRightPinnedColumnIndex = visibleColumns.length - visiblePinnedColumns.right.length;
      return targetIndex >= firstRightPinnedColumnIndex ? false : initialValue;
    }
    return initialValue;
  }, [apiRef]);
  const stateExportPreProcessing = React18.useCallback((prevState, context) => {
    var _a2;
    const pinnedColumnsToExport = gridPinnedColumnsSelector(apiRef.current.state);
    const shouldExportPinnedColumns = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the model is controlled
      props.pinnedColumns != null || // Always export if the model has been initialized
      ((_a2 = props.initialState) == null ? void 0 : _a2.pinnedColumns) != null || // Export if the model is not empty
      (pinnedColumnsToExport.left ?? []).length > 0 || (pinnedColumnsToExport.right ?? []).length > 0
    );
    if (!shouldExportPinnedColumns) {
      return prevState;
    }
    return _extends({}, prevState, {
      pinnedColumns: pinnedColumnsToExport
    });
  }, [apiRef, props.pinnedColumns, (_a = props.initialState) == null ? void 0 : _a.pinnedColumns]);
  const stateRestorePreProcessing = React18.useCallback((params, context) => {
    const newPinnedColumns = context.stateToRestore.pinnedColumns;
    if (newPinnedColumns != null) {
      setState(apiRef, newPinnedColumns);
    }
    return params;
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, "scrollToIndexes", calculateScrollLeft);
  useGridRegisterPipeProcessor(apiRef, "columnMenu", addColumnMenuItems);
  useGridRegisterPipeProcessor(apiRef, "canBeReordered", checkIfCanBeReordered);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  apiRef.current.registerControlState({
    stateId: "pinnedColumns",
    propModel: props.pinnedColumns,
    propOnChange: props.onPinnedColumnsChange,
    stateSelector: gridPinnedColumnsSelector,
    changeEvent: "pinnedColumnsChange"
  });
  const pinColumn = React18.useCallback((field, side) => {
    if (apiRef.current.isColumnPinned(field) === side) {
      return;
    }
    const otherSide = side === GridPinnedColumnPosition.RIGHT ? GridPinnedColumnPosition.LEFT : GridPinnedColumnPosition.RIGHT;
    const newPinnedColumns = {
      [side]: [...pinnedColumns[side] || [], field],
      [otherSide]: (pinnedColumns[otherSide] || []).filter((column) => column !== field)
    };
    apiRef.current.setPinnedColumns(newPinnedColumns);
  }, [apiRef, pinnedColumns]);
  const unpinColumn = React18.useCallback((field) => {
    apiRef.current.setPinnedColumns({
      left: (pinnedColumns.left || []).filter((column) => column !== field),
      right: (pinnedColumns.right || []).filter((column) => column !== field)
    });
  }, [apiRef, pinnedColumns.left, pinnedColumns.right]);
  const getPinnedColumns = React18.useCallback(() => {
    return gridPinnedColumnsSelector(apiRef.current.state);
  }, [apiRef]);
  const setPinnedColumns = React18.useCallback((newPinnedColumns) => {
    setState(apiRef, newPinnedColumns);
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const isColumnPinned = React18.useCallback((field) => {
    const leftPinnedColumns = pinnedColumns.left || [];
    if (leftPinnedColumns.includes(field)) {
      return GridPinnedColumnPosition.LEFT;
    }
    const rightPinnedColumns = pinnedColumns.right || [];
    if (rightPinnedColumns.includes(field)) {
      return GridPinnedColumnPosition.RIGHT;
    }
    return false;
  }, [pinnedColumns.left, pinnedColumns.right]);
  const columnPinningApi = {
    pinColumn,
    unpinColumn,
    getPinnedColumns,
    setPinnedColumns,
    isColumnPinned
  };
  useGridApiMethod(apiRef, columnPinningApi, "public");
  const handleColumnOrderChange = (params) => {
    if (!apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns) {
      return;
    }
    const {
      column,
      targetIndex,
      oldIndex
    } = params;
    const delta = targetIndex > oldIndex ? 1 : -1;
    const latestColumnFields = gridColumnFieldsSelector(apiRef);
    const siblingField = latestColumnFields[targetIndex - delta];
    const newOrderedFieldsBeforePinningColumns = [...apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns];
    let i2 = newOrderedFieldsBeforePinningColumns.findIndex((currentColumn) => currentColumn === column.field);
    let j = i2 + delta;
    const stop = newOrderedFieldsBeforePinningColumns.findIndex((currentColumn) => currentColumn === siblingField);
    while (delta > 0 ? i2 < stop : i2 > stop) {
      while (apiRef.current.isColumnPinned(newOrderedFieldsBeforePinningColumns[j])) {
        j += delta;
      }
      const temp = newOrderedFieldsBeforePinningColumns[i2];
      newOrderedFieldsBeforePinningColumns[i2] = newOrderedFieldsBeforePinningColumns[j];
      newOrderedFieldsBeforePinningColumns[j] = temp;
      i2 = j;
      j = i2 + delta;
    }
    apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;
  };
  useGridApiEventHandler(apiRef, "columnOrderChange", handleColumnOrderChange);
  React18.useEffect(() => {
    if (props.pinnedColumns) {
      apiRef.current.setPinnedColumns(props.pinnedColumns);
    }
  }, [apiRef, props.pinnedColumns]);
};
function setState(apiRef, model) {
  apiRef.current.setState((state) => _extends({}, state, {
    pinnedColumns: model
  }));
}

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/columnPinning/useGridColumnPinningPreProcessors.js
init_extends();
var React19 = __toESM(require_react());
var useGridColumnPinningPreProcessors = (apiRef, props) => {
  const {
    disableColumnPinning
  } = props;
  let pinnedColumns;
  if (apiRef.current.state.columns) {
    pinnedColumns = gridPinnedColumnsSelector(apiRef.current.state);
  } else {
    pinnedColumns = null;
  }
  const prevAllPinnedColumns = React19.useRef([]);
  const reorderPinnedColumns = React19.useCallback((columnsState) => {
    eslintUseValue(pinnedColumns);
    if (columnsState.orderedFields.length === 0 || disableColumnPinning) {
      return columnsState;
    }
    const savedState = apiRef.current.state;
    apiRef.current.state = _extends({}, savedState, {
      columns: columnsState
    });
    const visibleColumns = gridVisiblePinnedColumnDefinitionsSelector(apiRef);
    apiRef.current.state = savedState;
    const leftPinnedColumns = visibleColumns.left.map((c) => c.field);
    const rightPinnedColumns = visibleColumns.right.map((c) => c.field);
    let newOrderedFields;
    const allPinnedColumns = [...leftPinnedColumns, ...rightPinnedColumns];
    const {
      orderedFieldsBeforePinningColumns
    } = apiRef.current.caches.columnPinning;
    if (orderedFieldsBeforePinningColumns) {
      newOrderedFields = new Array(columnsState.orderedFields.length).fill(null);
      const newOrderedFieldsBeforePinningColumns = [...newOrderedFields];
      const remainingFields = [...columnsState.orderedFields];
      prevAllPinnedColumns.current.forEach((field) => {
        if (!allPinnedColumns.includes(field) && columnsState.lookup[field]) {
          const index = orderedFieldsBeforePinningColumns.indexOf(field);
          newOrderedFields[index] = field;
          newOrderedFieldsBeforePinningColumns[index] = field;
          remainingFields.splice(remainingFields.indexOf(field), 1);
        }
      });
      allPinnedColumns.forEach((field) => {
        let index = orderedFieldsBeforePinningColumns.indexOf(field);
        if (index === -1 || index >= newOrderedFieldsBeforePinningColumns.length) {
          index = columnsState.orderedFields.indexOf(field);
        }
        if (newOrderedFieldsBeforePinningColumns[index] !== null) {
          index = 0;
          while (newOrderedFieldsBeforePinningColumns[index] !== null) {
            index += 1;
          }
        }
        newOrderedFields[index] = field;
        newOrderedFieldsBeforePinningColumns[index] = field;
        remainingFields.splice(remainingFields.indexOf(field), 1);
      });
      let i2 = 0;
      remainingFields.forEach((field) => {
        while (newOrderedFieldsBeforePinningColumns[i2] !== null) {
          i2 += 1;
        }
        newOrderedFieldsBeforePinningColumns[i2] = field;
        newOrderedFields[i2] = field;
      });
      apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;
    } else {
      newOrderedFields = [...columnsState.orderedFields];
      apiRef.current.caches.columnPinning.orderedFieldsBeforePinningColumns = [...columnsState.orderedFields];
    }
    prevAllPinnedColumns.current = allPinnedColumns;
    const centerColumns = newOrderedFields.filter((field) => {
      return !leftPinnedColumns.includes(field) && !rightPinnedColumns.includes(field);
    });
    return _extends({}, columnsState, {
      orderedFields: [...leftPinnedColumns, ...centerColumns, ...rightPinnedColumns]
    });
  }, [apiRef, disableColumnPinning, pinnedColumns]);
  useGridRegisterPipeProcessor(apiRef, "hydrateColumns", reorderPinnedColumns);
  const isColumnPinned = React19.useCallback((initialValue, field) => apiRef.current.isColumnPinned(field), [apiRef]);
  useGridRegisterPipeProcessor(apiRef, "isColumnPinned", isColumnPinned);
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/detailPanel/useGridDetailPanel.js
init_extends();
var React21 = __toESM(require_react());

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/detailPanel/gridDetailPanelToggleColDef.js
init_extends();
var React20 = __toESM(require_react());
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var GRID_DETAIL_PANEL_TOGGLE_FIELD = "__detail_panel_toggle__";
var GRID_DETAIL_PANEL_TOGGLE_COL_DEF = _extends({}, GRID_STRING_COL_DEF, {
  type: "custom",
  field: GRID_DETAIL_PANEL_TOGGLE_FIELD,
  editable: false,
  sortable: false,
  filterable: false,
  resizable: false,
  // @ts-ignore
  aggregable: false,
  disableColumnMenu: true,
  disableReorder: true,
  disableExport: true,
  align: "left",
  width: 40,
  valueGetter: (value, row, column, apiRef) => {
    const rowId = apiRef.current.getRowId(row);
    const expandedRowIds = gridDetailPanelExpandedRowIdsSelector(apiRef.current.state);
    return expandedRowIds.includes(rowId);
  },
  renderCell: (params) => (0, import_jsx_runtime13.jsx)(GridDetailPanelToggleCell, _extends({}, params)),
  renderHeader: () => null
});

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/detailPanel/useGridDetailPanel.js
var detailPanelStateInitializer = (state, props) => {
  var _a, _b;
  return _extends({}, state, {
    detailPanel: {
      heightCache: {},
      expandedRowIds: props.detailPanelExpandedRowIds ?? ((_b = (_a = props.initialState) == null ? void 0 : _a.detailPanel) == null ? void 0 : _b.expandedRowIds) ?? []
    }
  });
};
function cacheContentAndHeight(apiRef, getDetailPanelContent, getDetailPanelHeight, previousHeightCache) {
  if (typeof getDetailPanelContent !== "function") {
    return {};
  }
  const rowIds = gridDataRowIdsSelector(apiRef);
  const contentCache = rowIds.reduce((acc, id) => {
    const params = apiRef.current.getRowParams(id);
    acc[id] = getDetailPanelContent(params);
    return acc;
  }, {});
  const heightCache = rowIds.reduce((acc, id) => {
    var _a;
    if (contentCache[id] == null) {
      return acc;
    }
    const params = apiRef.current.getRowParams(id);
    const height = getDetailPanelHeight(params);
    const autoHeight = height === "auto";
    acc[id] = {
      autoHeight,
      height: autoHeight ? (_a = previousHeightCache[id]) == null ? void 0 : _a.height : height
    };
    return acc;
  }, {});
  return {
    contentCache,
    heightCache
  };
}
var useGridDetailPanel = (apiRef, props) => {
  const expandedRowIds = useGridSelector(apiRef, gridDetailPanelExpandedRowIdsSelector);
  const contentCache = useGridSelector(apiRef, gridDetailPanelExpandedRowsContentCacheSelector);
  const handleCellClick = React21.useCallback((params, event) => {
    if (params.field !== GRID_DETAIL_PANEL_TOGGLE_FIELD || props.getDetailPanelContent == null) {
      return;
    }
    const content = contentCache[params.id];
    if (!React21.isValidElement(content)) {
      return;
    }
    if (event.target === event.currentTarget) {
      return;
    }
    apiRef.current.toggleDetailPanel(params.id);
  }, [apiRef, contentCache, props.getDetailPanelContent]);
  const handleCellKeyDown = React21.useCallback((params, event) => {
    if (props.getDetailPanelContent == null) {
      return;
    }
    if (params.field === GRID_DETAIL_PANEL_TOGGLE_FIELD && event.key === " ") {
      apiRef.current.toggleDetailPanel(params.id);
    }
  }, [apiRef, props.getDetailPanelContent]);
  useGridApiEventHandler(apiRef, "cellClick", handleCellClick);
  useGridApiEventHandler(apiRef, "cellKeyDown", handleCellKeyDown);
  apiRef.current.registerControlState({
    stateId: "detailPanels",
    propModel: props.detailPanelExpandedRowIds,
    propOnChange: props.onDetailPanelExpandedRowIdsChange,
    stateSelector: gridDetailPanelExpandedRowIdsSelector,
    changeEvent: "detailPanelsExpandedRowIdsChange"
  });
  const toggleDetailPanel = React21.useCallback((id) => {
    if (props.getDetailPanelContent == null) {
      return;
    }
    const content = contentCache[id];
    if (!React21.isValidElement(content)) {
      return;
    }
    const ids = apiRef.current.getExpandedDetailPanels();
    apiRef.current.setExpandedDetailPanels(ids.includes(id) ? ids.filter((rowId) => rowId !== id) : [...ids, id]);
  }, [apiRef, contentCache, props.getDetailPanelContent]);
  const getExpandedDetailPanels = React21.useCallback(() => gridDetailPanelExpandedRowIdsSelector(apiRef.current.state), [apiRef]);
  const setExpandedDetailPanels = React21.useCallback((ids) => {
    apiRef.current.setState((state) => {
      return _extends({}, state, {
        detailPanel: _extends({}, state.detailPanel, {
          expandedRowIds: ids
        })
      });
    });
    apiRef.current.updateDimensions();
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const storeDetailPanelHeight = React21.useCallback((id, height) => {
    const heightCache = gridDetailPanelRawHeightCacheSelector(apiRef.current.state);
    if (!heightCache[id] || heightCache[id].height === height) {
      return;
    }
    apiRef.current.setState((state) => {
      return _extends({}, state, {
        detailPanel: _extends({}, state.detailPanel, {
          heightCache: _extends({}, heightCache, {
            [id]: _extends({}, heightCache[id], {
              height
            })
          })
        })
      });
    });
    apiRef.current.updateDimensions();
    apiRef.current.requestPipeProcessorsApplication("rowHeight");
  }, [apiRef]);
  const detailPanelHasAutoHeight = React21.useCallback((id) => {
    const heightCache = gridDetailPanelRawHeightCacheSelector(apiRef.current.state);
    return heightCache[id] ? heightCache[id].autoHeight : false;
  }, [apiRef]);
  const detailPanelPubicApi = {
    toggleDetailPanel,
    getExpandedDetailPanels,
    setExpandedDetailPanels
  };
  const detailPanelPrivateApi = {
    storeDetailPanelHeight,
    detailPanelHasAutoHeight
  };
  useGridApiMethod(apiRef, detailPanelPubicApi, "public");
  useGridApiMethod(apiRef, detailPanelPrivateApi, "private");
  React21.useEffect(() => {
    if (props.detailPanelExpandedRowIds) {
      const currentModel = gridDetailPanelExpandedRowIdsSelector(apiRef.current.state);
      if (currentModel !== props.detailPanelExpandedRowIds) {
        apiRef.current.setExpandedDetailPanels(props.detailPanelExpandedRowIds);
      }
    }
  }, [apiRef, props.detailPanelExpandedRowIds]);
  const updateCachesAndForceUpdate = React21.useCallback(() => {
    var _a, _b;
    apiRef.current.setState((state) => {
      return _extends({}, state, {
        detailPanel: _extends({}, state.detailPanel, cacheContentAndHeight(apiRef, props.getDetailPanelContent, props.getDetailPanelHeight, state.detailPanel.heightCache))
      });
    });
    (_b = (_a = apiRef.current).updateDimensions) == null ? void 0 : _b.call(_a);
    apiRef.current.forceUpdate();
  }, [apiRef, props.getDetailPanelContent, props.getDetailPanelHeight]);
  useGridApiEventHandler(apiRef, "sortedRowsSet", updateCachesAndForceUpdate);
  const previousGetDetailPanelContentProp = React21.useRef();
  const previousGetDetailPanelHeightProp = React21.useRef();
  const updateCachesIfNeeded = React21.useCallback(() => {
    var _a, _b;
    if (props.getDetailPanelContent === previousGetDetailPanelContentProp.current && props.getDetailPanelHeight === previousGetDetailPanelHeightProp.current) {
      return;
    }
    apiRef.current.setState((state) => {
      return _extends({}, state, {
        detailPanel: _extends({}, state.detailPanel, cacheContentAndHeight(apiRef, props.getDetailPanelContent, props.getDetailPanelHeight, state.detailPanel.heightCache))
      });
    });
    (_b = (_a = apiRef.current).updateDimensions) == null ? void 0 : _b.call(_a);
    previousGetDetailPanelContentProp.current = props.getDetailPanelContent;
    previousGetDetailPanelHeightProp.current = props.getDetailPanelHeight;
  }, [apiRef, props.getDetailPanelContent, props.getDetailPanelHeight]);
  const addDetailHeight = React21.useCallback((initialValue, row) => {
    if (!expandedRowIds || expandedRowIds.length === 0 || !expandedRowIds.includes(row.id)) {
      initialValue.detail = 0;
      return initialValue;
    }
    updateCachesIfNeeded();
    const heightCache = gridDetailPanelExpandedRowsHeightCacheSelector(apiRef);
    initialValue.detail = heightCache[row.id] ?? 0;
    return initialValue;
  }, [apiRef, expandedRowIds, updateCachesIfNeeded]);
  useGridRegisterPipeProcessor(apiRef, "rowHeight", addDetailHeight);
  const isFirstRender = React21.useRef(true);
  if (isFirstRender.current) {
    isFirstRender.current = false;
    updateCachesIfNeeded();
  }
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/detailPanel/useGridDetailPanelPreProcessors.js
init_extends();
var React22 = __toESM(require_react());
var useGridDetailPanelPreProcessors = (privateApiRef, props) => {
  const addToggleColumn = React22.useCallback((columnsState) => {
    if (props.getDetailPanelContent == null) {
      if (columnsState.lookup[GRID_DETAIL_PANEL_TOGGLE_FIELD]) {
        delete columnsState.lookup[GRID_DETAIL_PANEL_TOGGLE_FIELD];
        columnsState.orderedFields = columnsState.orderedFields.filter((field) => field !== GRID_DETAIL_PANEL_TOGGLE_FIELD);
      }
      return columnsState;
    }
    if (columnsState.lookup[GRID_DETAIL_PANEL_TOGGLE_FIELD]) {
      return columnsState;
    }
    columnsState.orderedFields = [GRID_DETAIL_PANEL_TOGGLE_FIELD, ...columnsState.orderedFields];
    columnsState.lookup[GRID_DETAIL_PANEL_TOGGLE_FIELD] = _extends({}, GRID_DETAIL_PANEL_TOGGLE_COL_DEF, {
      headerName: privateApiRef.current.getLocaleText("detailPanelToggle")
    });
    return columnsState;
  }, [privateApiRef, props.getDetailPanelContent]);
  const addExpandedClassToRow = React22.useCallback((classes, id) => {
    if (props.getDetailPanelContent == null) {
      return classes;
    }
    const expandedRowIds = gridDetailPanelExpandedRowIdsSelector(privateApiRef.current.state);
    if (!expandedRowIds.includes(id)) {
      return classes;
    }
    return [...classes, gridClasses["row--detailPanelExpanded"]];
  }, [privateApiRef, props.getDetailPanelContent]);
  useGridRegisterPipeProcessor(privateApiRef, "hydrateColumns", addToggleColumn);
  useGridRegisterPipeProcessor(privateApiRef, "rowClassName", addExpandedClassToRow);
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/rowReorder/useGridRowReorder.js
var React24 = __toESM(require_react());
init_utils();

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/rowReorder/gridRowReorderColDef.js
init_extends();

// node_modules/@mui/x-data-grid-pro/esm/components/GridRowReorderCell.js
init_extends();
var React23 = __toESM(require_react());
init_utils();
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var useUtilityClasses5 = (ownerState) => {
  const {
    isDraggable,
    classes
  } = ownerState;
  const slots = {
    root: ["rowReorderCell", isDraggable && "rowReorderCell--draggable"],
    placeholder: ["rowReorderCellPlaceholder"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function GridRowReorderCell(params) {
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps2();
  const sortModel = useGridSelector(apiRef, gridSortModelSelector);
  const treeDepth = useGridSelector(apiRef, gridRowMaximumTreeDepthSelector);
  const editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);
  const cellValue = params.row.__reorder__ || params.id;
  const isDraggable = React23.useMemo(() => !!rootProps.rowReordering && !sortModel.length && treeDepth === 1 && Object.keys(editRowsState).length === 0, [rootProps.rowReordering, sortModel, treeDepth, editRowsState]);
  const ownerState = {
    isDraggable,
    classes: rootProps.classes
  };
  const classes = useUtilityClasses5(ownerState);
  const publish = React23.useCallback((eventName, propHandler) => (event) => {
    if (isEventTargetInPortal(event)) {
      return;
    }
    if (!apiRef.current.getRow(params.id)) {
      return;
    }
    apiRef.current.publishEvent(eventName, apiRef.current.getRowParams(params.id), event);
    if (propHandler) {
      propHandler(event);
    }
  }, [apiRef, params.id]);
  const draggableEventHandlers = isDraggable ? {
    onDragStart: publish("rowDragStart"),
    onDragOver: publish("rowDragOver"),
    onDragEnd: publish("rowDragEnd")
  } : null;
  if (params.rowNode.type === "footer") {
    return null;
  }
  return (0, import_jsx_runtime14.jsxs)("div", _extends({
    className: classes.root,
    draggable: isDraggable
  }, draggableEventHandlers, {
    children: [(0, import_jsx_runtime14.jsx)(rootProps.slots.rowReorderIcon, {}), (0, import_jsx_runtime14.jsx)("div", {
      className: classes.placeholder,
      children: cellValue
    })]
  }));
}
var renderRowReorderCell = (params) => {
  if (params.rowNode.type === "footer" || params.rowNode.type === "pinnedRow") {
    return null;
  }
  return (0, import_jsx_runtime14.jsx)(GridRowReorderCell, _extends({}, params));
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/rowReorder/gridRowReorderColDef.js
var GRID_REORDER_COL_DEF = _extends({}, GRID_STRING_COL_DEF, {
  type: "custom",
  field: "__reorder__",
  sortable: false,
  filterable: false,
  width: 50,
  align: "center",
  headerAlign: "center",
  disableColumnMenu: true,
  disableExport: true,
  disableReorder: true,
  resizable: false,
  // @ts-ignore
  aggregable: false,
  renderHeader: () => " ",
  renderCell: renderRowReorderCell
});

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/rowReorder/useGridRowReorder.js
var Direction = function(Direction2) {
  Direction2[Direction2["UP"] = 0] = "UP";
  Direction2[Direction2["DOWN"] = 1] = "DOWN";
  return Direction2;
}(Direction || {});
var previousMousePosition = null;
var previousReorderState = {
  previousTargetId: null,
  dragDirection: null
};
var useUtilityClasses6 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    rowDragging: ["row--dragging"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
var useGridRowReorder = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridRowReorder");
  const sortModel = useGridSelector(apiRef, gridSortModelSelector);
  const treeDepth = useGridSelector(apiRef, gridRowMaximumTreeDepthSelector);
  const dragRowNode = React24.useRef(null);
  const originRowIndex = React24.useRef(null);
  const removeDnDStylesTimeout = React24.useRef();
  const ownerState = {
    classes: props.classes
  };
  const classes = useUtilityClasses6(ownerState);
  const [dragRowId, setDragRowId] = React24.useState("");
  React24.useEffect(() => {
    return () => {
      clearTimeout(removeDnDStylesTimeout.current);
    };
  }, []);
  const isRowReorderDisabled = React24.useMemo(() => {
    return !props.rowReordering || !!sortModel.length || treeDepth !== 1;
  }, [props.rowReordering, sortModel, treeDepth]);
  const handleDragStart = React24.useCallback((params, event) => {
    const editRowsState = gridEditRowsStateSelector(apiRef.current.state);
    if (isRowReorderDisabled || Object.keys(editRowsState).length !== 0) {
      return;
    }
    logger.debug(`Start dragging row ${params.id}`);
    event.stopPropagation();
    dragRowNode.current = event.currentTarget;
    dragRowNode.current.classList.add(classes.rowDragging);
    setDragRowId(params.id);
    removeDnDStylesTimeout.current = setTimeout(() => {
      dragRowNode.current.classList.remove(classes.rowDragging);
    });
    originRowIndex.current = apiRef.current.getRowIndexRelativeToVisibleRows(params.id);
    apiRef.current.setCellFocus(params.id, GRID_REORDER_COL_DEF.field);
  }, [isRowReorderDisabled, classes.rowDragging, logger, apiRef]);
  const handleDragOver = React24.useCallback((params, event) => {
    if (dragRowId === "") {
      return;
    }
    const rowNode = apiRef.current.getRowNode(params.id);
    if (!rowNode || rowNode.type === "footer" || rowNode.type === "pinnedRow") {
      return;
    }
    logger.debug(`Dragging over row ${params.id}`);
    event.preventDefault();
    event.stopPropagation();
    const mouseMovementDiff = previousMousePosition ? previousMousePosition.y - event.clientY : event.clientY;
    if (params.id !== dragRowId) {
      const targetRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(params.id);
      const dragDirection = mouseMovementDiff > 0 ? Direction.DOWN : Direction.UP;
      const currentReorderState = {
        dragDirection,
        previousTargetId: params.id
      };
      const isStateChanged = currentReorderState.dragDirection !== previousReorderState.dragDirection || currentReorderState.previousTargetId !== previousReorderState.previousTargetId;
      if (previousReorderState.dragDirection === null || Math.abs(mouseMovementDiff) >= 1 && isStateChanged) {
        apiRef.current.setRowIndex(dragRowId, targetRowIndex);
        previousReorderState = currentReorderState;
      }
    }
    previousMousePosition = {
      x: event.clientX,
      y: event.clientY
    };
  }, [apiRef, logger, dragRowId]);
  const handleDragEnd = React24.useCallback((params, event) => {
    const editRowsState = gridEditRowsStateSelector(apiRef.current.state);
    if (dragRowId === "" || isRowReorderDisabled || Object.keys(editRowsState).length !== 0) {
      return;
    }
    logger.debug("End dragging row");
    event.preventDefault();
    event.stopPropagation();
    clearTimeout(removeDnDStylesTimeout.current);
    dragRowNode.current = null;
    previousReorderState.dragDirection = null;
    if (event.dataTransfer.dropEffect === "none") {
      apiRef.current.setRowIndex(dragRowId, originRowIndex.current);
      originRowIndex.current = null;
    } else {
      const rowOrderChangeParams = {
        row: apiRef.current.getRow(dragRowId),
        targetIndex: apiRef.current.getRowIndexRelativeToVisibleRows(params.id),
        oldIndex: originRowIndex.current
      };
      apiRef.current.publishEvent("rowOrderChange", rowOrderChangeParams);
    }
    setDragRowId("");
  }, [isRowReorderDisabled, logger, apiRef, dragRowId]);
  useGridApiEventHandler(apiRef, "rowDragStart", handleDragStart);
  useGridApiEventHandler(apiRef, "rowDragOver", handleDragOver);
  useGridApiEventHandler(apiRef, "rowDragEnd", handleDragEnd);
  useGridApiEventHandler(apiRef, "cellDragOver", handleDragOver);
  useGridApiOptionHandler(apiRef, "rowOrderChange", props.onRowOrderChange);
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/rowReorder/useGridRowReorderPreProcessors.js
init_extends();
var React25 = __toESM(require_react());
init_utils();
var useUtilityClasses7 = (ownerState) => {
  const {
    classes
  } = ownerState;
  return React25.useMemo(() => {
    const slots = {
      rowReorderCellContainer: ["rowReorderCellContainer"],
      columnHeaderReorder: ["columnHeaderReorder"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  }, [classes]);
};
var useGridRowReorderPreProcessors = (privateApiRef, props) => {
  const ownerState = {
    classes: props.classes
  };
  const classes = useUtilityClasses7(ownerState);
  const updateReorderColumn = React25.useCallback((columnsState) => {
    const reorderColumn = _extends({}, GRID_REORDER_COL_DEF, {
      cellClassName: classes.rowReorderCellContainer,
      headerClassName: classes.columnHeaderReorder,
      headerName: privateApiRef.current.getLocaleText("rowReorderingHeaderName")
    });
    const shouldHaveReorderColumn = props.rowReordering;
    const haveReorderColumn = columnsState.lookup[reorderColumn.field] != null;
    if (shouldHaveReorderColumn && haveReorderColumn) {
      return columnsState;
    }
    if (shouldHaveReorderColumn && !haveReorderColumn) {
      columnsState.lookup[reorderColumn.field] = reorderColumn;
      columnsState.orderedFields = [reorderColumn.field, ...columnsState.orderedFields];
    } else if (!shouldHaveReorderColumn && haveReorderColumn) {
      delete columnsState.lookup[reorderColumn.field];
      columnsState.orderedFields = columnsState.orderedFields.filter((field) => field !== reorderColumn.field);
    }
    return columnsState;
  }, [privateApiRef, classes, props.rowReordering]);
  useGridRegisterPipeProcessor(privateApiRef, "hydrateColumns", updateReorderColumn);
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/lazyLoader/useGridLazyLoader.js
var React26 = __toESM(require_react());
function findSkeletonRowsSection({
  apiRef,
  visibleRows,
  range
}) {
  var _a, _b;
  let {
    firstRowIndex,
    lastRowIndex
  } = range;
  const visibleRowsSection = visibleRows.slice(range.firstRowIndex, range.lastRowIndex);
  let startIndex = 0;
  let endIndex = visibleRowsSection.length - 1;
  let isSkeletonSectionFound = false;
  while (!isSkeletonSectionFound && firstRowIndex < lastRowIndex) {
    const isStartingWithASkeletonRow = ((_a = apiRef.current.getRowNode(visibleRowsSection[startIndex].id)) == null ? void 0 : _a.type) === "skeletonRow";
    const isEndingWithASkeletonRow = ((_b = apiRef.current.getRowNode(visibleRowsSection[endIndex].id)) == null ? void 0 : _b.type) === "skeletonRow";
    if (isStartingWithASkeletonRow && isEndingWithASkeletonRow) {
      isSkeletonSectionFound = true;
    }
    if (!isStartingWithASkeletonRow) {
      startIndex += 1;
      firstRowIndex += 1;
    }
    if (!isEndingWithASkeletonRow) {
      endIndex -= 1;
      lastRowIndex -= 1;
    }
  }
  return isSkeletonSectionFound ? {
    firstRowIndex,
    lastRowIndex
  } : void 0;
}
var useGridLazyLoader = (privateApiRef, props) => {
  const sortModel = useGridSelector(privateApiRef, gridSortModelSelector);
  const filterModel = useGridSelector(privateApiRef, gridFilterModelSelector);
  const renderedRowsIntervalCache = React26.useRef({
    firstRowToRender: 0,
    lastRowToRender: 0
  });
  const isDisabled = props.rowsLoadingMode !== "server";
  const handleRenderedRowsIntervalChange = React26.useCallback((params) => {
    if (isDisabled) {
      return;
    }
    const fetchRowsParams = {
      firstRowToRender: params.firstRowIndex,
      lastRowToRender: params.lastRowIndex,
      sortModel,
      filterModel
    };
    if (renderedRowsIntervalCache.current.firstRowToRender === params.firstRowIndex && renderedRowsIntervalCache.current.lastRowToRender === params.lastRowIndex) {
      return;
    }
    renderedRowsIntervalCache.current = {
      firstRowToRender: params.firstRowIndex,
      lastRowToRender: params.lastRowIndex
    };
    if (sortModel.length === 0 && filterModel.items.length === 0) {
      const currentVisibleRows = getVisibleRows(privateApiRef, {
        pagination: props.pagination,
        paginationMode: props.paginationMode
      });
      const skeletonRowsSection = findSkeletonRowsSection({
        apiRef: privateApiRef,
        visibleRows: currentVisibleRows.rows,
        range: {
          firstRowIndex: params.firstRowIndex,
          lastRowIndex: params.lastRowIndex
        }
      });
      if (!skeletonRowsSection) {
        return;
      }
      fetchRowsParams.firstRowToRender = skeletonRowsSection.firstRowIndex;
      fetchRowsParams.lastRowToRender = skeletonRowsSection.lastRowIndex;
    }
    privateApiRef.current.publishEvent("fetchRows", fetchRowsParams);
  }, [privateApiRef, isDisabled, props.pagination, props.paginationMode, sortModel, filterModel]);
  const handleGridSortModelChange = React26.useCallback((newSortModel) => {
    if (isDisabled) {
      return;
    }
    privateApiRef.current.requestPipeProcessorsApplication("hydrateRows");
    const renderContext = gridRenderContextSelector(privateApiRef);
    const fetchRowsParams = {
      firstRowToRender: renderContext.firstRowIndex,
      lastRowToRender: renderContext.lastRowIndex,
      sortModel: newSortModel,
      filterModel
    };
    privateApiRef.current.publishEvent("fetchRows", fetchRowsParams);
  }, [privateApiRef, isDisabled, filterModel]);
  const handleGridFilterModelChange = React26.useCallback((newFilterModel) => {
    if (isDisabled) {
      return;
    }
    privateApiRef.current.requestPipeProcessorsApplication("hydrateRows");
    const renderContext = gridRenderContextSelector(privateApiRef);
    const fetchRowsParams = {
      firstRowToRender: renderContext.firstRowIndex,
      lastRowToRender: renderContext.lastRowIndex,
      sortModel,
      filterModel: newFilterModel
    };
    privateApiRef.current.publishEvent("fetchRows", fetchRowsParams);
  }, [privateApiRef, isDisabled, sortModel]);
  useGridApiEventHandler(privateApiRef, "renderedRowsIntervalChange", handleRenderedRowsIntervalChange);
  useGridApiEventHandler(privateApiRef, "sortModelChange", handleGridSortModelChange);
  useGridApiEventHandler(privateApiRef, "filterModelChange", handleGridFilterModelChange);
  useGridApiOptionHandler(privateApiRef, "fetchRows", props.onFetchRows);
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/lazyLoader/useGridLazyLoaderPreProcessors.js
init_extends();
var React27 = __toESM(require_react());
var GRID_SKELETON_ROW_ROOT_ID = "auto-generated-skeleton-row-root";
var getSkeletonRowId = (index) => `${GRID_SKELETON_ROW_ROOT_ID}-${index}`;
var useGridLazyLoaderPreProcessors = (privateApiRef, props) => {
  const addSkeletonRows = React27.useCallback((groupingParams) => {
    const rootGroup = groupingParams.tree[GRID_ROOT_GROUP_ID];
    if (props.rowsLoadingMode !== "server" || !props.rowCount || rootGroup.children.length >= props.rowCount) {
      return groupingParams;
    }
    const tree = _extends({}, groupingParams.tree);
    const rootGroupChildren = [...rootGroup.children];
    for (let i2 = 0; i2 < props.rowCount - rootGroup.children.length; i2 += 1) {
      const skeletonId = getSkeletonRowId(i2);
      rootGroupChildren.push(skeletonId);
      const skeletonRowNode = {
        type: "skeletonRow",
        id: skeletonId,
        parent: GRID_ROOT_GROUP_ID,
        depth: 0
      };
      tree[skeletonId] = skeletonRowNode;
    }
    tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroup, {
      children: rootGroupChildren
    });
    return _extends({}, groupingParams, {
      tree
    });
  }, [props.rowCount, props.rowsLoadingMode]);
  useGridRegisterPipeProcessor(privateApiRef, "hydrateRows", addSkeletonRows);
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/rowPinning/useGridRowPinning.js
init_extends();
var React28 = __toESM(require_react());
function createPinnedRowsInternalCache(pinnedRows, getRowId) {
  var _a, _b;
  const cache = {
    topIds: [],
    bottomIds: [],
    idLookup: {}
  };
  (_a = pinnedRows == null ? void 0 : pinnedRows.top) == null ? void 0 : _a.forEach((rowModel) => {
    const id = getRowIdFromRowModel(rowModel, getRowId);
    cache.topIds.push(id);
    cache.idLookup[id] = rowModel;
  });
  (_b = pinnedRows == null ? void 0 : pinnedRows.bottom) == null ? void 0 : _b.forEach((rowModel) => {
    const id = getRowIdFromRowModel(rowModel, getRowId);
    cache.bottomIds.push(id);
    cache.idLookup[id] = rowModel;
  });
  return cache;
}
var rowPinningStateInitializer = (state, props, apiRef) => {
  var _a;
  apiRef.current.caches.pinnedRows = createPinnedRowsInternalCache(props.pinnedRows, props.getRowId);
  return _extends({}, state, {
    rows: _extends({}, state.rows, {
      additionalRowGroups: _extends({}, (_a = state.rows) == null ? void 0 : _a.additionalRowGroups, {
        pinnedRows: {
          top: [],
          bottom: []
        }
      })
    })
  });
};
var useGridRowPinning = (apiRef, props) => {
  const setPinnedRows = React28.useCallback((newPinnedRows) => {
    apiRef.current.caches.pinnedRows = createPinnedRowsInternalCache(newPinnedRows, props.getRowId);
    apiRef.current.requestPipeProcessorsApplication("hydrateRows");
  }, [apiRef, props.getRowId]);
  useGridApiMethod(apiRef, {
    unstable_setPinnedRows: setPinnedRows
  }, "public");
  const isFirstRender = React28.useRef(true);
  React28.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    apiRef.current.unstable_setPinnedRows(props.pinnedRows);
  }, [apiRef, props.pinnedRows]);
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/rowPinning/useGridRowPinningPreProcessors.js
init_extends();
var React29 = __toESM(require_react());
function addPinnedRow({
  groupingParams,
  rowModel,
  rowId,
  position,
  apiRef,
  isAutoGenerated
}) {
  var _a, _b, _c, _d;
  const dataRowIdToModelLookup = _extends({}, groupingParams.dataRowIdToModelLookup);
  const dataRowIdToIdLookup = _extends({}, groupingParams.dataRowIdToIdLookup);
  const tree = _extends({}, groupingParams.tree);
  const treeDepths = _extends({}, groupingParams.treeDepths);
  const node = {
    type: "pinnedRow",
    id: rowId,
    depth: 0,
    parent: GRID_ROOT_GROUP_ID,
    isAutoGenerated
  };
  insertNodeInTree(node, tree, treeDepths, null);
  if (!isAutoGenerated) {
    dataRowIdToModelLookup[rowId] = rowModel;
    dataRowIdToIdLookup[rowId] = rowId;
  }
  apiRef.current.caches.rows.dataRowIdToModelLookup[rowId] = _extends({}, rowModel);
  apiRef.current.caches.rows.dataRowIdToIdLookup[rowId] = rowId;
  const previousPinnedRows = ((_a = groupingParams.additionalRowGroups) == null ? void 0 : _a.pinnedRows) || {};
  const newPinnedRow = {
    id: rowId,
    model: rowModel
  };
  if ((_d = (_c = (_b = groupingParams.additionalRowGroups) == null ? void 0 : _b.pinnedRows) == null ? void 0 : _c[position]) == null ? void 0 : _d.includes(newPinnedRow)) {
    return _extends({}, groupingParams, {
      dataRowIdToModelLookup,
      dataRowIdToIdLookup,
      tree,
      treeDepths
    });
  }
  return _extends({}, groupingParams, {
    dataRowIdToModelLookup,
    dataRowIdToIdLookup,
    tree,
    treeDepths,
    additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {
      pinnedRows: _extends({}, previousPinnedRows, {
        [position]: [...previousPinnedRows[position] || [], newPinnedRow]
      })
    })
  });
}
var useGridRowPinningPreProcessors = (apiRef) => {
  const addPinnedRows = React29.useCallback((groupingParams) => {
    var _a, _b, _c, _d;
    const pinnedRowsCache = apiRef.current.caches.pinnedRows || {};
    let newGroupingParams = _extends({}, groupingParams, {
      additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {
        // reset pinned rows state
        pinnedRows: {}
      })
    });
    (_a = pinnedRowsCache.topIds) == null ? void 0 : _a.forEach((rowId) => {
      newGroupingParams = addPinnedRow({
        groupingParams: newGroupingParams,
        rowModel: pinnedRowsCache.idLookup[rowId],
        rowId,
        position: "top",
        apiRef,
        isAutoGenerated: false
      });
    });
    (_b = pinnedRowsCache.bottomIds) == null ? void 0 : _b.forEach((rowId) => {
      newGroupingParams = addPinnedRow({
        groupingParams: newGroupingParams,
        rowModel: pinnedRowsCache.idLookup[rowId],
        rowId,
        position: "bottom",
        apiRef,
        isAutoGenerated: false
      });
    });
    if (((_c = pinnedRowsCache.bottomIds) == null ? void 0 : _c.length) || ((_d = pinnedRowsCache.topIds) == null ? void 0 : _d.length)) {
      const shouldKeepRow = (rowId) => {
        if (newGroupingParams.tree[rowId] && newGroupingParams.tree[rowId].type === "pinnedRow") {
          return false;
        }
        return true;
      };
      const rootGroupNode = newGroupingParams.tree[GRID_ROOT_GROUP_ID];
      newGroupingParams.tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroupNode, {
        children: rootGroupNode.children.filter(shouldKeepRow)
      });
      newGroupingParams.dataRowIds = newGroupingParams.dataRowIds.filter(shouldKeepRow);
    }
    return newGroupingParams;
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, "hydrateRows", addPinnedRows);
};

// node_modules/@mui/x-data-grid-pro/esm/DataGridPro/useDataGridProComponent.js
var useDataGridProComponent = (inputApiRef, props) => {
  const apiRef = useGridInitialization(inputApiRef, props);
  useGridRowSelectionPreProcessors(apiRef, props);
  useGridRowReorderPreProcessors(apiRef, props);
  useGridTreeDataPreProcessors(apiRef, props);
  useGridLazyLoaderPreProcessors(apiRef, props);
  useGridRowPinningPreProcessors(apiRef);
  useGridDetailPanelPreProcessors(apiRef, props);
  useGridColumnPinningPreProcessors(apiRef, props);
  useGridRowsPreProcessors(apiRef);
  useGridInitializeState(dimensionsStateInitializer, apiRef, props);
  useGridInitializeState(headerFilteringStateInitializer, apiRef, props);
  useGridInitializeState(rowSelectionStateInitializer, apiRef, props);
  useGridInitializeState(detailPanelStateInitializer, apiRef, props);
  useGridInitializeState(columnPinningStateInitializer, apiRef, props);
  useGridInitializeState(columnsStateInitializer, apiRef, props);
  useGridInitializeState(rowPinningStateInitializer, apiRef, props);
  useGridInitializeState(rowsStateInitializer, apiRef, props);
  useGridInitializeState(editingStateInitializer, apiRef, props);
  useGridInitializeState(focusStateInitializer, apiRef, props);
  useGridInitializeState(sortingStateInitializer, apiRef, props);
  useGridInitializeState(preferencePanelStateInitializer, apiRef, props);
  useGridInitializeState(filterStateInitializer, apiRef, props);
  useGridInitializeState(densityStateInitializer, apiRef, props);
  useGridInitializeState(columnReorderStateInitializer, apiRef, props);
  useGridInitializeState(columnResizeStateInitializer, apiRef, props);
  useGridInitializeState(paginationStateInitializer, apiRef, props);
  useGridInitializeState(rowsMetaStateInitializer, apiRef, props);
  useGridInitializeState(columnMenuStateInitializer, apiRef, props);
  useGridInitializeState(columnGroupsStateInitializer, apiRef, props);
  useGridInitializeState(virtualizationStateInitializer, apiRef, props);
  useGridHeaderFiltering(apiRef, props);
  useGridTreeData(apiRef);
  useGridKeyboardNavigation(apiRef, props);
  useGridRowSelection(apiRef, props);
  useGridColumnPinning(apiRef, props);
  useGridRowPinning(apiRef, props);
  useGridColumns(apiRef, props);
  useGridRows(apiRef, props);
  useGridParamsApi(apiRef);
  useGridDetailPanel(apiRef, props);
  useGridColumnSpanning(apiRef);
  useGridColumnGrouping(apiRef, props);
  useGridEditing(apiRef, props);
  useGridFocus(apiRef, props);
  useGridPreferencesPanel(apiRef, props);
  useGridFilter(apiRef, props);
  useGridSorting(apiRef, props);
  useGridDensity(apiRef, props);
  useGridColumnReorder(apiRef, props);
  useGridColumnResize(apiRef, props);
  useGridPagination(apiRef, props);
  useGridRowsMeta(apiRef, props);
  useGridRowReorder(apiRef, props);
  useGridScroll(apiRef, props);
  useGridInfiniteLoader(apiRef, props);
  useGridLazyLoader(apiRef, props);
  useGridColumnMenu(apiRef);
  useGridCsvExport(apiRef, props);
  useGridPrintExport(apiRef, props);
  useGridClipboard(apiRef, props);
  useGridDimensions(apiRef, props);
  useGridEvents(apiRef, props);
  useGridStatePersistence(apiRef);
  useGridVirtualization(apiRef, props);
  return apiRef;
};

// node_modules/@mui/x-data-grid-pro/esm/DataGridPro/useDataGridProProps.js
init_extends();
var React36 = __toESM(require_react());

// node_modules/@mui/x-data-grid-pro/esm/constants/dataGridProDefaultSlotsComponents.js
init_extends();

// node_modules/@mui/x-data-grid-pro/esm/components/GridProColumnMenu.js
init_extends();
var React30 = __toESM(require_react());
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var GRID_COLUMN_MENU_SLOTS_PRO = _extends({}, GRID_COLUMN_MENU_SLOTS, {
  columnMenuPinningItem: GridColumnMenuPinningItem
});
var GRID_COLUMN_MENU_SLOT_PROPS_PRO = _extends({}, GRID_COLUMN_MENU_SLOT_PROPS, {
  columnMenuPinningItem: {
    displayOrder: 15
  }
});
var GridProColumnMenu = React30.forwardRef(function GridProColumnMenu2(props, ref) {
  return (0, import_jsx_runtime15.jsx)(GridGenericColumnMenu, _extends({
    ref
  }, props, {
    defaultSlots: GRID_COLUMN_MENU_SLOTS_PRO,
    defaultSlotProps: GRID_COLUMN_MENU_SLOT_PROPS_PRO
  }));
});

// node_modules/@mui/x-data-grid-pro/esm/components/GridColumnHeaders.js
init_extends();
init_objectWithoutPropertiesLoose();
var React32 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());

// node_modules/@mui/x-data-grid-pro/esm/hooks/features/columnHeaders/useGridColumnHeaders.js
init_extends();
init_objectWithoutPropertiesLoose();
var React31 = __toESM(require_react());
init_utils();
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var _excluded4 = ["getColumnsToRender", "renderContext", "leftRenderContext", "rightRenderContext", "pinnedColumns", "visibleColumns", "getCellOffsetStyle"];
var useUtilityClasses8 = (ownerState) => {
  const {
    classes
  } = ownerState;
  return React31.useMemo(() => {
    const slots = {
      headerFilterRow: ["headerFilterRow"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  }, [classes]);
};
var filterItemsCache = /* @__PURE__ */ Object.create(null);
var useGridColumnHeaders2 = (props) => {
  const apiRef = useGridPrivateApiContext();
  const {
    headerGroupingMaxDepth,
    hasOtherElementInTabSequence
  } = props;
  const columnHeaderFilterTabIndexState = useGridSelector(apiRef, gridTabIndexColumnHeaderFilterSelector);
  const _useGridColumnHeaders = useGridColumnHeaders(_extends({}, props, {
    hasOtherElementInTabSequence: hasOtherElementInTabSequence || columnHeaderFilterTabIndexState !== null
  })), {
    getColumnsToRender,
    renderContext,
    leftRenderContext,
    rightRenderContext,
    pinnedColumns,
    visibleColumns,
    getCellOffsetStyle
  } = _useGridColumnHeaders, otherProps = _objectWithoutPropertiesLoose(_useGridColumnHeaders, _excluded4);
  const headerFiltersRef = React31.useRef(null);
  apiRef.current.register("private", {
    headerFiltersElementRef: headerFiltersRef
  });
  const headerFilterMenuRef = React31.useRef(null);
  const rootProps = useGridRootProps2();
  const classes = useUtilityClasses8(rootProps);
  const disableHeaderFiltering = !rootProps.headerFilters;
  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);
  const filterModel = useGridSelector(apiRef, gridFilterModelSelector);
  const gridHasFiller = dimensions.columnsTotalWidth < dimensions.viewportOuterSize.width;
  const columnHeaderFilterFocus = useGridSelector(apiRef, gridFocusColumnHeaderFilterSelector);
  const getFilterItem = React31.useCallback((colDef) => {
    const filterModelItem = filterModel == null ? void 0 : filterModel.items.find((it) => it.field === colDef.field && it.operator !== "isAnyOf");
    if (filterModelItem != null) {
      return filterModelItem;
    }
    const defaultCachedItem = filterItemsCache[colDef.field];
    if (defaultCachedItem != null) {
      return defaultCachedItem;
    }
    const defaultItem = getGridFilter(colDef);
    filterItemsCache[colDef.field] = defaultItem;
    return defaultItem;
  }, [filterModel]);
  const getColumnFilters = (params) => {
    var _a;
    const {
      renderedColumns,
      firstColumnToRender
    } = getColumnsToRender(params);
    const filters = [];
    for (let i2 = 0; i2 < renderedColumns.length; i2 += 1) {
      const colDef = renderedColumns[i2];
      const columnIndex = firstColumnToRender + i2;
      const hasFocus = (columnHeaderFilterFocus == null ? void 0 : columnHeaderFilterFocus.field) === colDef.field;
      const isFirstColumn = columnIndex === 0;
      const tabIndexField = columnHeaderFilterTabIndexState == null ? void 0 : columnHeaderFilterTabIndexState.field;
      const tabIndex = tabIndexField === colDef.field || isFirstColumn && !props.hasOtherElementInTabSequence ? 0 : -1;
      const headerClassName = typeof colDef.headerClassName === "function" ? colDef.headerClassName({
        field: colDef.field,
        colDef
      }) : colDef.headerClassName;
      const item = getFilterItem(colDef);
      const pinnedPosition = params == null ? void 0 : params.position;
      const style = getCellOffsetStyle({
        pinnedPosition,
        columnIndex,
        computedWidth: colDef.computedWidth
      });
      filters.push((0, import_jsx_runtime16.jsx)(rootProps.slots.headerFilterCell, _extends({
        colIndex: columnIndex,
        height: dimensions.headerFilterHeight,
        width: colDef.computedWidth,
        colDef,
        hasFocus,
        tabIndex,
        headerFilterMenuRef,
        headerClassName,
        "data-field": colDef.field,
        item,
        pinnedPosition,
        style,
        indexInSection: i2,
        sectionLength: renderedColumns.length,
        gridHasFiller
      }, (_a = rootProps.slotProps) == null ? void 0 : _a.headerFilterCell), `${colDef.field}-filter`));
    }
    return otherProps.getFillers(params, filters, 0, true);
  };
  const getColumnFiltersRow = () => {
    if (disableHeaderFiltering) {
      return null;
    }
    return (0, import_jsx_runtime16.jsxs)(GridColumnHeaderRow, {
      ref: headerFiltersRef,
      className: classes.headerFilterRow,
      role: "row",
      "aria-rowindex": headerGroupingMaxDepth + 2,
      ownerState: rootProps,
      children: [leftRenderContext && getColumnFilters({
        position: GridPinnedColumnPosition.LEFT,
        renderContext: leftRenderContext,
        minFirstColumn: leftRenderContext.firstColumnIndex,
        maxLastColumn: leftRenderContext.lastColumnIndex
      }), getColumnFilters({
        renderContext,
        minFirstColumn: pinnedColumns.left.length,
        maxLastColumn: visibleColumns.length - pinnedColumns.right.length
      }), rightRenderContext && getColumnFilters({
        position: GridPinnedColumnPosition.RIGHT,
        renderContext: rightRenderContext,
        minFirstColumn: rightRenderContext.firstColumnIndex,
        maxLastColumn: rightRenderContext.lastColumnIndex
      })]
    });
  };
  return _extends({}, otherProps, {
    getColumnFiltersRow
  });
};

// node_modules/@mui/x-data-grid-pro/esm/components/GridColumnHeaders.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var _excluded5 = ["style", "className", "visibleColumns", "sortColumnLookup", "filterColumnLookup", "columnHeaderTabIndexState", "columnGroupHeaderTabIndexState", "columnHeaderFocus", "columnGroupHeaderFocus", "headerGroupingMaxDepth", "columnMenuState", "columnVisibility", "columnGroupsHeaderStructure", "hasOtherElementInTabSequence"];
var Filler = styled_default("div")({
  flex: 1,
  backgroundColor: "var(--DataGrid-containerBackground)"
});
var GridColumnHeaders = React32.forwardRef(function GridColumnHeaders2(props, ref) {
  const {
    className,
    visibleColumns,
    sortColumnLookup,
    filterColumnLookup,
    columnHeaderTabIndexState,
    columnGroupHeaderTabIndexState,
    columnHeaderFocus,
    columnGroupHeaderFocus,
    headerGroupingMaxDepth,
    columnMenuState,
    columnVisibility,
    columnGroupsHeaderStructure,
    hasOtherElementInTabSequence
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  const {
    getInnerProps,
    getColumnHeadersRow,
    getColumnFiltersRow,
    getColumnGroupHeadersRows
  } = useGridColumnHeaders2({
    visibleColumns,
    sortColumnLookup,
    filterColumnLookup,
    columnHeaderTabIndexState,
    hasOtherElementInTabSequence,
    columnGroupHeaderTabIndexState,
    columnHeaderFocus,
    columnGroupHeaderFocus,
    headerGroupingMaxDepth,
    columnMenuState,
    columnVisibility,
    columnGroupsHeaderStructure
  });
  return (0, import_jsx_runtime17.jsxs)(GridBaseColumnHeaders, _extends({
    ref,
    className
  }, other, getInnerProps(), {
    children: [getColumnGroupHeadersRows(), getColumnHeadersRow(), getColumnFiltersRow(), (0, import_jsx_runtime17.jsx)(Filler, {})]
  }));
});
true ? GridColumnHeaders.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  columnGroupHeaderFocus: import_prop_types7.default.shape({
    depth: import_prop_types7.default.number.isRequired,
    field: import_prop_types7.default.string.isRequired
  }),
  columnGroupHeaderTabIndexState: import_prop_types7.default.shape({
    depth: import_prop_types7.default.number.isRequired,
    field: import_prop_types7.default.string.isRequired
  }),
  columnGroupsHeaderStructure: import_prop_types7.default.arrayOf(import_prop_types7.default.arrayOf(import_prop_types7.default.shape({
    columnFields: import_prop_types7.default.arrayOf(import_prop_types7.default.string).isRequired,
    groupId: import_prop_types7.default.string
  }))).isRequired,
  columnHeaderFocus: import_prop_types7.default.shape({
    field: import_prop_types7.default.string.isRequired
  }),
  columnHeaderTabIndexState: import_prop_types7.default.shape({
    field: import_prop_types7.default.string.isRequired
  }),
  columnMenuState: import_prop_types7.default.shape({
    field: import_prop_types7.default.string,
    open: import_prop_types7.default.bool.isRequired
  }).isRequired,
  columnVisibility: import_prop_types7.default.object.isRequired,
  filterColumnLookup: import_prop_types7.default.object.isRequired,
  hasOtherElementInTabSequence: import_prop_types7.default.bool.isRequired,
  headerGroupingMaxDepth: import_prop_types7.default.number.isRequired,
  sortColumnLookup: import_prop_types7.default.object.isRequired,
  visibleColumns: import_prop_types7.default.arrayOf(import_prop_types7.default.object).isRequired
} : void 0;

// node_modules/@mui/x-data-grid-pro/esm/components/GridDetailPanels.js
var React34 = __toESM(require_react());
init_utils();

// node_modules/@mui/x-data-grid-pro/esm/hooks/utils/useGridPrivateApiContext.js
var useGridPrivateApiContext2 = useGridPrivateApiContext;

// node_modules/@mui/x-data-grid-pro/esm/components/GridDetailPanel.js
var React33 = __toESM(require_react());
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var DetailPanel = styled_default("div", {
  name: "MuiDataGrid",
  slot: "DetailPanel",
  overridesResolver: (props, styles) => styles.detailPanel
})(({
  theme
}) => ({
  width: "calc(var(--DataGrid-rowWidth) - var(--DataGrid-hasScrollY) * var(--DataGrid-scrollbarSize))",
  backgroundColor: (theme.vars || theme).palette.background.default,
  overflow: "auto"
}));
function GridDetailPanel(props) {
  const {
    rowId,
    height,
    className,
    children
  } = props;
  const apiRef = useGridPrivateApiContext2();
  const ref = React33.useRef(null);
  const rootProps = useGridRootProps2();
  const ownerState = rootProps;
  const hasAutoHeight = height === "auto";
  React33.useLayoutEffect(() => {
    if (hasAutoHeight && typeof ResizeObserver === "undefined") {
      apiRef.current.storeDetailPanelHeight(rowId, ref.current.clientHeight);
    }
  }, [apiRef, hasAutoHeight, rowId]);
  useResizeObserver(ref, (entries) => {
    const [entry] = entries;
    const observedHeight = entry.borderBoxSize && entry.borderBoxSize.length > 0 ? entry.borderBoxSize[0].blockSize : entry.contentRect.height;
    apiRef.current.storeDetailPanelHeight(rowId, observedHeight);
  }, hasAutoHeight);
  return (0, import_jsx_runtime18.jsx)(DetailPanel, {
    ref,
    ownerState,
    role: "presentation",
    style: {
      height
    },
    className,
    children
  });
}

// node_modules/@mui/x-data-grid-pro/esm/components/GridDetailPanels.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var useUtilityClasses9 = () => {
  const slots = {
    detailPanel: ["detailPanel"]
  };
  return composeClasses(slots, getDataGridUtilityClass, {});
};
function GridDetailPanels(props) {
  const rootProps = useGridRootProps2();
  if (!rootProps.getDetailPanelContent) {
    return null;
  }
  return React34.createElement(GridDetailPanelsImpl, props);
}
function GridDetailPanelsImpl({
  virtualScroller
}) {
  const apiRef = useGridPrivateApiContext2();
  const classes = useUtilityClasses9();
  const {
    setPanels
  } = virtualScroller;
  const expandedRowIds = useGridSelector(apiRef, gridDetailPanelExpandedRowIdsSelector);
  const detailPanelsContent = useGridSelector(apiRef, gridDetailPanelExpandedRowsContentCacheSelector);
  const detailPanelsHeights = useGridSelector(apiRef, gridDetailPanelExpandedRowsHeightCacheSelector);
  const getDetailPanel = React34.useCallback((rowId) => {
    const content = detailPanelsContent[rowId];
    const rowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(rowId);
    const exists = rowIndex !== void 0;
    if (!React34.isValidElement(content) || !exists) {
      return null;
    }
    const hasAutoHeight = apiRef.current.detailPanelHasAutoHeight(rowId);
    const height = hasAutoHeight ? "auto" : detailPanelsHeights[rowId];
    return (0, import_jsx_runtime19.jsx)(GridDetailPanel, {
      rowId,
      height,
      className: classes.detailPanel,
      children: content
    }, `panel-${rowId}`);
  }, [apiRef, classes.detailPanel, detailPanelsHeights, detailPanelsContent]);
  React34.useEffect(() => {
    if (expandedRowIds.length === 0) {
      setPanels(EMPTY_DETAIL_PANELS);
    } else {
      setPanels(new Map(expandedRowIds.map((rowId) => [rowId, getDetailPanel(rowId)])));
    }
  }, [expandedRowIds, setPanels, getDetailPanel]);
  return null;
}

// node_modules/@mui/x-data-grid-pro/esm/components/GridPinnedRows.js
var React35 = __toESM(require_react());
init_clsx();
init_utils();
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var useUtilityClasses10 = () => {
  const slots = {
    root: ["pinnedRows"]
  };
  return composeClasses(slots, getDataGridUtilityClass, {});
};
function GridPinnedRows({
  position,
  virtualScroller
}) {
  const classes = useUtilityClasses10();
  const apiRef = useGridPrivateApiContext();
  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);
  const pinnedRowsData = useGridSelector(apiRef, gridPinnedRowsSelector);
  const rows = pinnedRowsData[position];
  const pinnedRenderContext = React35.useMemo(() => ({
    firstRowIndex: 0,
    lastRowIndex: rows.length,
    firstColumnIndex: renderContext.firstColumnIndex,
    lastColumnIndex: renderContext.lastColumnIndex
  }), [rows, renderContext.firstColumnIndex, renderContext.lastColumnIndex]);
  if (rows.length === 0) {
    return null;
  }
  const pinnedRows = virtualScroller.getRows({
    position,
    rows,
    renderContext: pinnedRenderContext
  });
  return (0, import_jsx_runtime20.jsx)("div", {
    className: clsx_default(classes.root, gridClasses[`pinnedRows--${position}`]),
    role: "presentation",
    children: pinnedRows
  });
}

// node_modules/@mui/x-data-grid-pro/esm/material/index.js
init_extends();
var iconSlots = {
  columnMenuPinRightIcon: GridPushPinRightIcon,
  columnMenuPinLeftIcon: GridPushPinLeftIcon
};
var materialSlots = _extends({}, iconSlots);
var material_default = materialSlots;

// node_modules/@mui/x-data-grid-pro/esm/constants/dataGridProDefaultSlotsComponents.js
var DATA_GRID_PRO_DEFAULT_SLOTS_COMPONENTS = _extends({}, DATA_GRID_DEFAULT_SLOTS_COMPONENTS, material_default, {
  columnMenu: GridProColumnMenu,
  columnHeaders: GridColumnHeaders,
  detailPanels: GridDetailPanels,
  headerFilterCell: Memoized,
  headerFilterMenu: GridHeaderFilterMenu,
  pinnedRows: GridPinnedRows
});

// node_modules/@mui/x-data-grid-pro/esm/DataGridPro/useDataGridProProps.js
var DATA_GRID_PRO_PROPS_DEFAULT_VALUES = _extends({}, DATA_GRID_PROPS_DEFAULT_VALUES, {
  scrollEndThreshold: 80,
  treeData: false,
  defaultGroupingExpansionDepth: 0,
  autosizeOnMount: false,
  disableAutosize: false,
  disableColumnPinning: false,
  keepColumnPositionIfDraggedOutside: false,
  disableChildrenFiltering: false,
  disableChildrenSorting: false,
  rowReordering: false,
  rowsLoadingMode: "client",
  getDetailPanelHeight: () => 500,
  headerFilters: false
});
var defaultSlots = DATA_GRID_PRO_DEFAULT_SLOTS_COMPONENTS;
var useDataGridProProps = (inProps) => {
  const themedProps = useProps(
    // eslint-disable-next-line material-ui/mui-name-matches-component-name
    useThemeProps({
      props: inProps,
      name: "MuiDataGrid"
    })
  );
  const localeText = React36.useMemo(() => _extends({}, GRID_DEFAULT_LOCALE_TEXT, themedProps.localeText), [themedProps.localeText]);
  const slots = React36.useMemo(() => computeSlots({
    defaultSlots,
    slots: themedProps.slots
  }), [themedProps.slots]);
  return React36.useMemo(() => _extends({}, DATA_GRID_PRO_PROPS_DEFAULT_VALUES, themedProps, {
    localeText,
    slots,
    signature: "DataGridPro"
  }), [themedProps, localeText, slots]);
};

// node_modules/@mui/x-data-grid-pro/esm/utils/releaseInfo.js
init_utils();
var getReleaseInfo = () => {
  const releaseInfo2 = "MTcxNzEwMjgwMDAwMA==";
  if (true) {
    if (releaseInfo2 === "__RELEASE_INFO__") {
      return ponyfillGlobal_default.__MUI_RELEASE_INFO__;
    }
  }
  return releaseInfo2;
};

// node_modules/@mui/x-data-grid-pro/esm/internals/propValidation.js
var propValidatorsDataGridPro = [...propValidatorsDataGrid, (props) => props.pagination && props.hideFooterRowCount && "MUI X: The `hideFooterRowCount` prop has no effect when the pagination is enabled." || void 0, (props) => props.treeData && props.filterMode === "server" && 'MUI X: The `filterMode="server"` prop is not available when the `treeData` is enabled.' || void 0, (props) => !props.pagination && props.checkboxSelectionVisibleOnly && "MUI X: The `checkboxSelectionVisibleOnly` prop has no effect when the pagination is not enabled." || void 0, (props) => props.signature !== GridSignature.DataGrid && props.paginationMode === "client" && props.rowsLoadingMode !== "server" && isNumber(props.rowCount) && 'MUI X: Usage of the `rowCount` prop with client side pagination (`paginationMode="client"`) has no effect. `rowCount` is only meant to be used with `paginationMode="server"`.' || void 0];

// node_modules/@mui/x-data-grid-pro/esm/DataGridPro/DataGridPro.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var releaseInfo = getReleaseInfo();
var DataGridProRaw = React37.forwardRef(function DataGridPro(inProps, ref) {
  const props = useDataGridProProps(inProps);
  const privateApiRef = useDataGridProComponent(props.apiRef, props);
  useLicenseVerifier("x-data-grid-pro", releaseInfo);
  if (true) {
    validateProps(props, propValidatorsDataGridPro);
  }
  return (0, import_jsx_runtime21.jsx)(GridContextProvider, {
    privateApiRef,
    props,
    children: (0, import_jsx_runtime21.jsxs)(GridRoot, _extends({
      className: props.className,
      style: props.style,
      sx: props.sx,
      ref
    }, props.forwardedProps, {
      children: [(0, import_jsx_runtime21.jsx)(GridHeader, {}), (0, import_jsx_runtime21.jsx)(GridVirtualScroller, {
        children: (0, import_jsx_runtime21.jsx)(Watermark, {
          packageName: "x-data-grid-pro",
          releaseInfo
        })
      }), (0, import_jsx_runtime21.jsx)(GridFooterPlaceholder, {})]
    }))
  });
});
var DataGridPro2 = React37.memo(DataGridProRaw);
DataGridProRaw.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The ref object that allows grid manipulation. Can be instantiated with `useGridApiRef()`.
   */
  apiRef: import_prop_types8.default.shape({
    current: import_prop_types8.default.object.isRequired
  }),
  /**
   * The label of the Data Grid.
   */
  "aria-label": import_prop_types8.default.string,
  /**
   * The id of the element containing a label for the Data Grid.
   */
  "aria-labelledby": import_prop_types8.default.string,
  /**
   * If `true`, the Data Grid height is dynamic and follows the number of rows in the Data Grid.
   * @default false
   */
  autoHeight: import_prop_types8.default.bool,
  /**
   * If `true`, the pageSize is calculated according to the container size and the max number of rows to avoid rendering a vertical scroll bar.
   * @default false
   */
  autoPageSize: import_prop_types8.default.bool,
  /**
   * If `true`, columns are autosized after the datagrid is mounted.
   * @default false
   */
  autosizeOnMount: import_prop_types8.default.bool,
  /**
   * The options for autosize when user-initiated.
   */
  autosizeOptions: import_prop_types8.default.shape({
    columns: import_prop_types8.default.arrayOf(import_prop_types8.default.string),
    expand: import_prop_types8.default.bool,
    includeHeaders: import_prop_types8.default.bool,
    includeOutliers: import_prop_types8.default.bool,
    outliersFactor: import_prop_types8.default.number
  }),
  /**
   * Controls the modes of the cells.
   */
  cellModesModel: import_prop_types8.default.object,
  /**
   * If `true`, the Data Grid will display an extra column with checkboxes for selecting rows.
   * @default false
   */
  checkboxSelection: import_prop_types8.default.bool,
  /**
   * If `true`, the "Select All" header checkbox selects only the rows on the current page. To be used in combination with `checkboxSelection`.
   * It only works if the pagination is enabled.
   * @default false
   */
  checkboxSelectionVisibleOnly: import_prop_types8.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types8.default.object,
  /**
   * The character used to separate cell values when copying to the clipboard.
   * @default '\t'
   */
  clipboardCopyCellDelimiter: import_prop_types8.default.string,
  /**
   * Column region in pixels to render before/after the viewport
   * @default 150
   */
  columnBufferPx: import_prop_types8.default.number,
  columnGroupingModel: import_prop_types8.default.arrayOf(import_prop_types8.default.object),
  /**
   * Sets the height in pixel of the column headers in the Data Grid.
   * @default 56
   */
  columnHeaderHeight: import_prop_types8.default.number,
  /**
   * Set of columns of type [[GridColDef]][].
   */
  columns: import_prop_types8.default.arrayOf(import_prop_types8.default.object).isRequired,
  /**
   * Set the column visibility model of the Data Grid.
   * If defined, the Data Grid will ignore the `hide` property in [[GridColDef]].
   */
  columnVisibilityModel: import_prop_types8.default.object,
  /**
   * If above 0, the row children will be expanded up to this depth.
   * If equal to -1, all the row children will be expanded.
   * @default 0
   */
  defaultGroupingExpansionDepth: import_prop_types8.default.number,
  /**
   * Set the density of the Data Grid.
   * @default "standard"
   */
  density: import_prop_types8.default.oneOf(["comfortable", "compact", "standard"]),
  /**
   * The row ids to show the detail panel.
   */
  detailPanelExpandedRowIds: import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.number, import_prop_types8.default.string]).isRequired),
  /**
   * If `true`, column autosizing on header separator double-click is disabled.
   * @default false
   */
  disableAutosize: import_prop_types8.default.bool,
  /**
   * If `true`, the filtering will only be applied to the top level rows when grouping rows with the `treeData` prop.
   * @default false
   */
  disableChildrenFiltering: import_prop_types8.default.bool,
  /**
   * If `true`, the sorting will only be applied to the top level rows when grouping rows with the `treeData` prop.
   * @default false
   */
  disableChildrenSorting: import_prop_types8.default.bool,
  /**
   * If `true`, column filters are disabled.
   * @default false
   */
  disableColumnFilter: import_prop_types8.default.bool,
  /**
   * If `true`, the column menu is disabled.
   * @default false
   */
  disableColumnMenu: import_prop_types8.default.bool,
  /**
   * If `true`, the column pinning is disabled.
   * @default false
   */
  disableColumnPinning: import_prop_types8.default.bool,
  /**
   * If `true`, reordering columns is disabled.
   * @default false
   */
  disableColumnReorder: import_prop_types8.default.bool,
  /**
   * If `true`, resizing columns is disabled.
   * @default false
   */
  disableColumnResize: import_prop_types8.default.bool,
  /**
   * If `true`, hiding/showing columns is disabled.
   * @default false
   */
  disableColumnSelector: import_prop_types8.default.bool,
  /**
   * If `true`, the column sorting feature will be disabled.
   * @default false
   */
  disableColumnSorting: import_prop_types8.default.bool,
  /**
   * If `true`, the density selector is disabled.
   * @default false
   */
  disableDensitySelector: import_prop_types8.default.bool,
  /**
   * If `true`, `eval()` is not used for performance optimization.
   * @default false
   */
  disableEval: import_prop_types8.default.bool,
  /**
   * If `true`, filtering with multiple columns is disabled.
   * @default false
   */
  disableMultipleColumnsFiltering: import_prop_types8.default.bool,
  /**
   * If `true`, the sorting with multiple columns is disabled.
   * @default false
   */
  disableMultipleColumnsSorting: import_prop_types8.default.bool,
  /**
   * If `true`, multiple selection using the Ctrl/CMD or Shift key is disabled.
   * The MIT DataGrid will ignore this prop, unless `checkboxSelection` is enabled.
   * @default false (`!props.checkboxSelection` for MIT Data Grid)
   */
  disableMultipleRowSelection: import_prop_types8.default.bool,
  /**
   * If `true`, the selection on click on a row or cell is disabled.
   * @default false
   */
  disableRowSelectionOnClick: import_prop_types8.default.bool,
  /**
   * If `true`, the virtualization is disabled.
   * @default false
   */
  disableVirtualization: import_prop_types8.default.bool,
  /**
   * Controls whether to use the cell or row editing.
   * @default "cell"
   */
  editMode: import_prop_types8.default.oneOf(["cell", "row"]),
  /**
   * Use if the actual rowCount is not known upfront, but an estimation is available.
   * If some rows have children (for instance in the tree data), this number represents the amount of top level rows.
   * Applicable only with `paginationMode="server"` and when `rowCount="-1"`
   */
  estimatedRowCount: import_prop_types8.default.number,
  /**
   * Unstable features, breaking changes might be introduced.
   * For each feature, if the flag is not explicitly set to `true`, the feature will be fully disabled and any property / method call will not have any effect.
   */
  experimentalFeatures: import_prop_types8.default.shape({
    warnIfFocusStateIsNotSynced: import_prop_types8.default.bool
  }),
  /**
   * The milliseconds delay to wait after a keystroke before triggering filtering.
   * @default 150
   */
  filterDebounceMs: import_prop_types8.default.number,
  /**
   * Filtering can be processed on the server or client-side.
   * Set it to 'server' if you would like to handle filtering on the server-side.
   * @default "client"
   */
  filterMode: import_prop_types8.default.oneOf(["client", "server"]),
  /**
   * Set the filter model of the Data Grid.
   */
  filterModel: import_prop_types8.default.shape({
    items: import_prop_types8.default.arrayOf(import_prop_types8.default.shape({
      field: import_prop_types8.default.string.isRequired,
      id: import_prop_types8.default.oneOfType([import_prop_types8.default.number, import_prop_types8.default.string]),
      operator: import_prop_types8.default.string.isRequired,
      value: import_prop_types8.default.any
    })).isRequired,
    logicOperator: import_prop_types8.default.oneOf(["and", "or"]),
    quickFilterExcludeHiddenColumns: import_prop_types8.default.bool,
    quickFilterLogicOperator: import_prop_types8.default.oneOf(["and", "or"]),
    quickFilterValues: import_prop_types8.default.array
  }),
  /**
   * Forwarded props for the Data Grid root element.
   * @ignore - do not document.
   */
  forwardedProps: import_prop_types8.default.object,
  /**
   * Function that applies CSS classes dynamically on cells.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @returns {string} The CSS class to apply to the cell.
   */
  getCellClassName: import_prop_types8.default.func,
  /**
   * Function that returns the element to render in row detail.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @returns {React.JSX.Element} The row detail element.
   */
  getDetailPanelContent: import_prop_types8.default.func,
  /**
   * Function that returns the height of the row detail panel.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @returns {number | string} The height in pixels or "auto" to use the content height.
   * @default "() => 500"
   */
  getDetailPanelHeight: import_prop_types8.default.func,
  /**
   * Function that returns the estimated height for a row.
   * Only works if dynamic row height is used.
   * Once the row height is measured this value is discarded.
   * @param {GridRowHeightParams} params With all properties from [[GridRowHeightParams]].
   * @returns {number | null} The estimated row height value. If `null` or `undefined` then the default row height, based on the density, is applied.
   */
  getEstimatedRowHeight: import_prop_types8.default.func,
  /**
   * Function that applies CSS classes dynamically on rows.
   * @param {GridRowClassNameParams} params With all properties from [[GridRowClassNameParams]].
   * @returns {string} The CSS class to apply to the row.
   */
  getRowClassName: import_prop_types8.default.func,
  /**
   * Function that sets the row height per row.
   * @param {GridRowHeightParams} params With all properties from [[GridRowHeightParams]].
   * @returns {GridRowHeightReturnValue} The row height value. If `null` or `undefined` then the default row height is applied. If "auto" then the row height is calculated based on the content.
   */
  getRowHeight: import_prop_types8.default.func,
  /**
   * Return the id of a given [[GridRowModel]].
   */
  getRowId: import_prop_types8.default.func,
  /**
   * Function that allows to specify the spacing between rows.
   * @param {GridRowSpacingParams} params With all properties from [[GridRowSpacingParams]].
   * @returns {GridRowSpacing} The row spacing values.
   */
  getRowSpacing: import_prop_types8.default.func,
  /**
   * Determines the path of a row in the tree data.
   * For instance, a row with the path ["A", "B"] is the child of the row with the path ["A"].
   * Note that all paths must contain at least one element.
   * @template R
   * @param {R} row The row from which we want the path.
   * @returns {string[]} The path to the row.
   */
  getTreeDataPath: import_prop_types8.default.func,
  /**
   * The grouping column used by the tree data.
   */
  groupingColDef: import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.object]),
  /**
   * Override the height of the header filters.
   */
  headerFilterHeight: import_prop_types8.default.number,
  /**
   * If `true`, enables the data grid filtering on header feature.
   * @default false
   */
  headerFilters: import_prop_types8.default.bool,
  /**
   * If `true`, the footer component is hidden.
   * @default false
   */
  hideFooter: import_prop_types8.default.bool,
  /**
   * If `true`, the pagination component in the footer is hidden.
   * @default false
   */
  hideFooterPagination: import_prop_types8.default.bool,
  /**
   * If `true`, the row count in the footer is hidden.
   * It has no effect if the pagination is enabled.
   * @default false
   */
  hideFooterRowCount: import_prop_types8.default.bool,
  /**
   * If `true`, the selected row count in the footer is hidden.
   * @default false
   */
  hideFooterSelectedRowCount: import_prop_types8.default.bool,
  /**
   * If `true`, the diacritics (accents) are ignored when filtering or quick filtering.
   * E.g. when filter value is `cafe`, the rows with `cafÃ©` will be visible.
   * @default false
   */
  ignoreDiacritics: import_prop_types8.default.bool,
  /**
   * If `true`, the Data Grid will not use `valueFormatter` when exporting to CSV or copying to clipboard.
   * If an object is provided, you can choose to ignore the `valueFormatter` for CSV export or clipboard export.
   * @default false
   */
  ignoreValueFormatterDuringExport: import_prop_types8.default.oneOfType([import_prop_types8.default.shape({
    clipboardExport: import_prop_types8.default.bool,
    csvExport: import_prop_types8.default.bool
  }), import_prop_types8.default.bool]),
  /**
   * The initial state of the DataGridPro.
   * The data in it will be set in the state on initialization but will not be controlled.
   * If one of the data in `initialState` is also being controlled, then the control state wins.
   */
  initialState: import_prop_types8.default.object,
  /**
   * Callback fired when a cell is rendered, returns true if the cell is editable.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @returns {boolean} A boolean indicating if the cell is editable.
   */
  isCellEditable: import_prop_types8.default.func,
  /**
   * Determines if a group should be expanded after its creation.
   * This prop takes priority over the `defaultGroupingExpansionDepth` prop.
   * @param {GridGroupNode} node The node of the group to test.
   * @returns {boolean} A boolean indicating if the group is expanded.
   */
  isGroupExpandedByDefault: import_prop_types8.default.func,
  /**
   * Determines if a row can be selected.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @returns {boolean} A boolean indicating if the cell is selectable.
   */
  isRowSelectable: import_prop_types8.default.func,
  /**
   * If `true`, moving the mouse pointer outside the grid before releasing the mouse button
   * in a column re-order action will not cause the column to jump back to its original position.
   * @default false
   */
  keepColumnPositionIfDraggedOutside: import_prop_types8.default.bool,
  /**
   * If `true`, the selection model will retain selected rows that do not exist.
   * Useful when using server side pagination and row selections need to be retained
   * when changing pages.
   * @default false
   */
  keepNonExistentRowsSelected: import_prop_types8.default.bool,
  /**
   * If `true`, a loading overlay is displayed.
   */
  loading: import_prop_types8.default.bool,
  /**
   * Set the locale text of the Data Grid.
   * You can find all the translation keys supported in [the source](https://github.com/mui/mui-x/blob/HEAD/packages/x-data-grid/src/constants/localeTextConstants.ts) in the GitHub repository.
   */
  localeText: import_prop_types8.default.object,
  /**
   * Pass a custom logger in the components that implements the [[Logger]] interface.
   * @default console
   */
  logger: import_prop_types8.default.shape({
    debug: import_prop_types8.default.func.isRequired,
    error: import_prop_types8.default.func.isRequired,
    info: import_prop_types8.default.func.isRequired,
    warn: import_prop_types8.default.func.isRequired
  }),
  /**
   * Allows to pass the logging level or false to turn off logging.
   * @default "error" ("warn" in dev mode)
   */
  logLevel: import_prop_types8.default.oneOf(["debug", "error", "info", "warn", false]),
  /**
   * Nonce of the inline styles for [Content Security Policy](https://www.w3.org/TR/2016/REC-CSP2-20161215/#script-src-the-nonce-attribute).
   */
  nonce: import_prop_types8.default.string,
  /**
   * Callback fired when any cell is clicked.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onCellClick: import_prop_types8.default.func,
  /**
   * Callback fired when a double click event comes from a cell element.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onCellDoubleClick: import_prop_types8.default.func,
  /**
   * Callback fired when the cell turns to edit mode.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<React.KeyboardEvent | React.MouseEvent>} event The event that caused this prop to be called.
   */
  onCellEditStart: import_prop_types8.default.func,
  /**
   * Callback fired when the cell turns to view mode.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
   */
  onCellEditStop: import_prop_types8.default.func,
  /**
   * Callback fired when a keydown event comes from a cell element.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<React.KeyboardEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onCellKeyDown: import_prop_types8.default.func,
  /**
   * Callback fired when the `cellModesModel` prop changes.
   * @param {GridCellModesModel} cellModesModel Object containing which cells are in "edit" mode.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onCellModesModelChange: import_prop_types8.default.func,
  /**
   * Callback called when the data is copied to the clipboard.
   * @param {string} data The data copied to the clipboard.
   */
  onClipboardCopy: import_prop_types8.default.func,
  /**
   * Callback fired when a click event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderClick: import_prop_types8.default.func,
  /**
   * Callback fired when a double click event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderDoubleClick: import_prop_types8.default.func,
  /**
   * Callback fired when a mouse enter event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderEnter: import_prop_types8.default.func,
  /**
   * Callback fired when a mouse leave event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderLeave: import_prop_types8.default.func,
  /**
   * Callback fired when a mouseout event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderOut: import_prop_types8.default.func,
  /**
   * Callback fired when a mouseover event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderOver: import_prop_types8.default.func,
  /**
   * Callback fired when a column is reordered.
   * @param {GridColumnOrderChangeParams} params With all properties from [[GridColumnOrderChangeParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnOrderChange: import_prop_types8.default.func,
  /**
   * Callback fired while a column is being resized.
   * @param {GridColumnResizeParams} params With all properties from [[GridColumnResizeParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnResize: import_prop_types8.default.func,
  /**
   * Callback fired when the column visibility model changes.
   * @param {GridColumnVisibilityModel} model The new model.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnVisibilityModelChange: import_prop_types8.default.func,
  /**
   * Callback fired when the width of a column is changed.
   * @param {GridColumnResizeParams} params With all properties from [[GridColumnResizeParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnWidthChange: import_prop_types8.default.func,
  /**
   * Callback fired when the density changes.
   * @param {GridDensity} density New density value.
   */
  onDensityChange: import_prop_types8.default.func,
  /**
   * Callback fired when the detail panel of a row is opened or closed.
   * @param {GridRowId[]} ids The ids of the rows which have the detail panel open.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onDetailPanelExpandedRowIdsChange: import_prop_types8.default.func,
  /**
   * Callback fired when rowCount is set and the next batch of virtualized rows is rendered.
   * @param {GridFetchRowsParams} params With all properties from [[GridFetchRowsParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onFetchRows: import_prop_types8.default.func,
  /**
   * Callback fired when the Filter model changes before the filters are applied.
   * @param {GridFilterModel} model With all properties from [[GridFilterModel]].
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onFilterModelChange: import_prop_types8.default.func,
  /**
   * Callback fired when the menu is closed.
   * @param {GridMenuParams} params With all properties from [[GridMenuParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onMenuClose: import_prop_types8.default.func,
  /**
   * Callback fired when the menu is opened.
   * @param {GridMenuParams} params With all properties from [[GridMenuParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onMenuOpen: import_prop_types8.default.func,
  /**
   * Callback fired when the pagination meta has changed.
   * @param {GridPaginationMeta} paginationMeta Updated pagination meta.
   */
  onPaginationMetaChange: import_prop_types8.default.func,
  /**
   * Callback fired when the pagination model has changed.
   * @param {GridPaginationModel} model Updated pagination model.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onPaginationModelChange: import_prop_types8.default.func,
  /**
   * Callback fired when the pinned columns have changed.
   * @param {GridPinnedColumnFields} pinnedColumns The changed pinned columns.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onPinnedColumnsChange: import_prop_types8.default.func,
  /**
   * Callback fired when the preferences panel is closed.
   * @param {GridPreferencePanelParams} params With all properties from [[GridPreferencePanelParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onPreferencePanelClose: import_prop_types8.default.func,
  /**
   * Callback fired when the preferences panel is opened.
   * @param {GridPreferencePanelParams} params With all properties from [[GridPreferencePanelParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onPreferencePanelOpen: import_prop_types8.default.func,
  /**
   * Callback called when `processRowUpdate` throws an error or rejects.
   * @param {any} error The error thrown.
   */
  onProcessRowUpdateError: import_prop_types8.default.func,
  /**
   * Callback fired when the Data Grid is resized.
   * @param {ElementSize} containerSize With all properties from [[ElementSize]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onResize: import_prop_types8.default.func,
  /**
   * Callback fired when a row is clicked.
   * Not called if the target clicked is an interactive element added by the built-in columns.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowClick: import_prop_types8.default.func,
  /**
   * Callback fired when the row count has changed.
   * @param {number} count Updated row count.
   */
  onRowCountChange: import_prop_types8.default.func,
  /**
   * Callback fired when a double click event comes from a row container element.
   * @param {GridRowParams} params With all properties from [[RowParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowDoubleClick: import_prop_types8.default.func,
  /**
   * Callback fired when the row turns to edit mode.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @param {MuiEvent<React.KeyboardEvent | React.MouseEvent>} event The event that caused this prop to be called.
   */
  onRowEditStart: import_prop_types8.default.func,
  /**
   * Callback fired when the row turns to view mode.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
   */
  onRowEditStop: import_prop_types8.default.func,
  /**
   * Callback fired when the `rowModesModel` prop changes.
   * @param {GridRowModesModel} rowModesModel Object containing which rows are in "edit" mode.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowModesModelChange: import_prop_types8.default.func,
  /**
   * Callback fired when a row is being reordered.
   * @param {GridRowOrderChangeParams} params With all properties from [[GridRowOrderChangeParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowOrderChange: import_prop_types8.default.func,
  /**
   * Callback fired when the selection state of one or multiple rows changes.
   * @param {GridRowSelectionModel} rowSelectionModel With all the row ids [[GridSelectionModel]].
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowSelectionModelChange: import_prop_types8.default.func,
  /**
   * Callback fired when scrolling to the bottom of the grid viewport.
   * @param {GridRowScrollEndParams} params With all properties from [[GridRowScrollEndParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowsScrollEnd: import_prop_types8.default.func,
  /**
   * Callback fired when the sort model changes before a column is sorted.
   * @param {GridSortModel} model With all properties from [[GridSortModel]].
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onSortModelChange: import_prop_types8.default.func,
  /**
   * Callback fired when the state of the Data Grid is updated.
   * @param {GridState} state The new state.
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   * @ignore - do not document.
   */
  onStateChange: import_prop_types8.default.func,
  /**
   * Select the pageSize dynamically using the component UI.
   * @default [25, 50, 100]
   */
  pageSizeOptions: import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.number, import_prop_types8.default.shape({
    label: import_prop_types8.default.string.isRequired,
    value: import_prop_types8.default.number.isRequired
  })]).isRequired),
  /**
   * If `true`, pagination is enabled.
   * @default false
   */
  pagination: import_prop_types8.default.bool,
  /**
   * The extra information about the pagination state of the Data Grid.
   * Only applicable with `paginationMode="server"`.
   */
  paginationMeta: import_prop_types8.default.shape({
    hasNextPage: import_prop_types8.default.bool
  }),
  /**
   * Pagination can be processed on the server or client-side.
   * Set it to 'client' if you would like to handle the pagination on the client-side.
   * Set it to 'server' if you would like to handle the pagination on the server-side.
   * @default "client"
   */
  paginationMode: import_prop_types8.default.oneOf(["client", "server"]),
  /**
   * The pagination model of type [[GridPaginationModel]] which refers to current `page` and `pageSize`.
   */
  paginationModel: import_prop_types8.default.shape({
    page: import_prop_types8.default.number.isRequired,
    pageSize: import_prop_types8.default.number.isRequired
  }),
  /**
   * The column fields to display pinned to left or right.
   */
  pinnedColumns: import_prop_types8.default.object,
  /**
   * Rows data to pin on top or bottom.
   */
  pinnedRows: import_prop_types8.default.shape({
    bottom: import_prop_types8.default.arrayOf(import_prop_types8.default.object),
    top: import_prop_types8.default.arrayOf(import_prop_types8.default.object)
  }),
  /**
   * Callback called before updating a row with new values in the row and cell editing.
   * @template R
   * @param {R} newRow Row object with the new values.
   * @param {R} oldRow Row object with the old values.
   * @returns {Promise<R> | R} The final values to update the row.
   */
  processRowUpdate: import_prop_types8.default.func,
  /**
   * The milliseconds throttle delay for resizing the grid.
   * @default 60
   */
  resizeThrottleMs: import_prop_types8.default.number,
  /**
   * Row region in pixels to render before/after the viewport
   * @default 150
   */
  rowBufferPx: import_prop_types8.default.number,
  /**
   * Set the total number of rows, if it is different from the length of the value `rows` prop.
   * If some rows have children (for instance in the tree data), this number represents the amount of top level rows.
   * Only works with `paginationMode="server"`, ignored when `paginationMode="client"`.
   */
  rowCount: import_prop_types8.default.number,
  /**
   * Sets the height in pixel of a row in the Data Grid.
   * @default 52
   */
  rowHeight: import_prop_types8.default.number,
  /**
   * Controls the modes of the rows.
   */
  rowModesModel: import_prop_types8.default.object,
  /**
   * The milliseconds delay to wait after measuring the row height before recalculating row positions.
   * Setting it to a lower value could be useful when using dynamic row height,
   * but might reduce performance when displaying a large number of rows.
   * @default 166
   */
  rowPositionsDebounceMs: import_prop_types8.default.number,
  /**
   * If `true`, the reordering of rows is enabled.
   * @default false
   */
  rowReordering: import_prop_types8.default.bool,
  /**
   * Set of rows of type [[GridRowsProp]].
   * @default []
   */
  rows: import_prop_types8.default.arrayOf(import_prop_types8.default.object),
  /**
   * If `false`, the row selection mode is disabled.
   * @default true
   */
  rowSelection: import_prop_types8.default.bool,
  /**
   * Sets the row selection model of the Data Grid.
   */
  rowSelectionModel: import_prop_types8.default.oneOfType([import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.number, import_prop_types8.default.string]).isRequired), import_prop_types8.default.number, import_prop_types8.default.string]),
  /**
   * Loading rows can be processed on the server or client-side.
   * Set it to 'client' if you would like enable infnite loading.
   * Set it to 'server' if you would like to enable lazy loading.
   * * @default "client"
   */
  rowsLoadingMode: import_prop_types8.default.oneOf(["client", "server"]),
  /**
   * Sets the type of space between rows added by `getRowSpacing`.
   * @default "margin"
   */
  rowSpacingType: import_prop_types8.default.oneOf(["border", "margin"]),
  /**
   * Override the height/width of the Data Grid inner scrollbar.
   */
  scrollbarSize: import_prop_types8.default.number,
  /**
   * Set the area in `px` at the bottom of the grid viewport where onRowsScrollEnd is called.
   * @default 80
   */
  scrollEndThreshold: import_prop_types8.default.number,
  /**
   * If `true`, the vertical borders of the cells are displayed.
   * @default false
   */
  showCellVerticalBorder: import_prop_types8.default.bool,
  /**
   * If `true`, the right border of the column headers are displayed.
   * @default false
   */
  showColumnVerticalBorder: import_prop_types8.default.bool,
  /**
   * Overridable components props dynamically passed to the component at rendering.
   */
  slotProps: import_prop_types8.default.object,
  /**
   * Overridable components.
   */
  slots: import_prop_types8.default.object,
  /**
   * Sorting can be processed on the server or client-side.
   * Set it to 'client' if you would like to handle sorting on the client-side.
   * Set it to 'server' if you would like to handle sorting on the server-side.
   * @default "client"
   */
  sortingMode: import_prop_types8.default.oneOf(["client", "server"]),
  /**
   * The order of the sorting sequence.
   * @default ['asc', 'desc', null]
   */
  sortingOrder: import_prop_types8.default.arrayOf(import_prop_types8.default.oneOf(["asc", "desc"])),
  /**
   * Set the sort model of the Data Grid.
   */
  sortModel: import_prop_types8.default.arrayOf(import_prop_types8.default.shape({
    field: import_prop_types8.default.string.isRequired,
    sort: import_prop_types8.default.oneOf(["asc", "desc"])
  })),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types8.default.oneOfType([import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.object, import_prop_types8.default.bool])), import_prop_types8.default.func, import_prop_types8.default.object]),
  /**
   * If positive, the Data Grid will throttle updates coming from `apiRef.current.updateRows` and `apiRef.current.setRows`.
   * It can be useful if you have a high update rate but do not want to do heavy work like filtering / sorting or rendering on each  individual update.
   * @default 0
   */
  throttleRowsMs: import_prop_types8.default.number,
  /**
   * If `true`, the rows will be gathered in a tree structure according to the `getTreeDataPath` prop.
   * @default false
   */
  treeData: import_prop_types8.default.bool
};

// node_modules/@mui/x-data-grid-pro/esm/hooks/utils/useGridApiRef.js
var useGridApiRef2 = useGridApiRef;

// node_modules/@mui/x-data-grid-pro/esm/index.js
var LicenseInfo2 = class extends LicenseInfo {
};

export {
  useLicenseVerifier,
  Watermark,
  useGridRootProps2 as useGridRootProps,
  useGridApiContext2 as useGridApiContext,
  GridTreeDataGroupingCell,
  GridColumnMenuPinningItem,
  headerFilteringStateInitializer,
  useGridHeaderFiltering,
  gridDetailPanelExpandedRowIdsSelector,
  gridDetailPanelExpandedRowsContentCacheSelector,
  gridDetailPanelExpandedRowsHeightCacheSelector,
  GridDetailPanelToggleCell,
  GridPushPinRightIcon,
  GridPushPinLeftIcon,
  GridHeaderFilterMenuContainer,
  Memoized,
  GridHeaderFilterMenu,
  gridColumnReorderSelector,
  gridColumnReorderDragColSelector,
  GRID_REORDER_COL_DEF,
  GRID_TREE_DATA_GROUPING_FIELD,
  GRID_DETAIL_PANEL_TOGGLE_FIELD,
  GRID_DETAIL_PANEL_TOGGLE_COL_DEF,
  getGroupRowIdFromPath,
  insertNodeInTree,
  removeNodeFromTree,
  getVisibleRowsLookup,
  DataGrid,
  DataGridPremium,
  useGridInfiniteLoader,
  columnReorderStateInitializer,
  useGridColumnReorder,
  useGridTreeData,
  createRowTree,
  sortRowTree,
  updateRowTree,
  useGridTreeDataPreProcessors,
  columnPinningStateInitializer,
  useGridColumnPinning,
  useGridColumnPinningPreProcessors,
  detailPanelStateInitializer,
  useGridDetailPanel,
  useGridDetailPanelPreProcessors,
  useGridRowReorder,
  useGridRowReorderPreProcessors,
  useGridLazyLoader,
  useGridLazyLoaderPreProcessors,
  rowPinningStateInitializer,
  useGridRowPinning,
  addPinnedRow,
  useGridRowPinningPreProcessors,
  GRID_COLUMN_MENU_SLOTS_PRO,
  GRID_COLUMN_MENU_SLOT_PROPS_PRO,
  GridProColumnMenu,
  GridColumnHeaders,
  DATA_GRID_PRO_DEFAULT_SLOTS_COMPONENTS,
  DATA_GRID_PRO_PROPS_DEFAULT_VALUES,
  propValidatorsDataGridPro,
  DataGridPro2 as DataGridPro,
  useGridApiRef2 as useGridApiRef,
  LicenseInfo2 as LicenseInfo
};
/*! Bundled license information:

@mui/x-license/index.js:
  (**
   * @mui/x-license v7.6.1
   *
   * @license MUI X Commercial
   * This source code is licensed under the commercial license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-FVBC47BQ.js.map
